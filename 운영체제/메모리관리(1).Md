# 메모리 관리(1)
1. 메모리 관리 개념

### 가. 메모리 관리 기법
- 메인 메모리는 운영체제를 위한 영역 중인 프로그램을 위한 영역으로 구분
- 메모리 관리 : 다중프로그래밍 시스템에서 운영체제에 의해 동적으로 메모리의 사용자 영역을 여러 프로세스가 상주할 수 있도록 세분화하는 과정

**반입 정책**
- 메인 메모리에 적재할 다음 프로세스의 반입시기하는 방법
  - 요구 반입 기법 : 운영체제나 시스템 프로그램, 사용자 프로그램 등의 참조 요구에 따라 메인 메모리에 적재 방법으로 오랫동안 사용
  - 예상 반입 기법 : 시스템의 요구를 예측하여 메모리에 미리 적재하는 방법으로 최근 사용되기 시작, 요구되는 페이지 외의 다른 페이지도 함께들임, 탐색시간, 회전 지연 시간을 갖는 보조기억장치의 특성을 참조한 정책

**배치 정책**
- 디스크에 반입한 프로세스를 메인 메모리 어느 위치에 저장할 것인가를 결정하는 방법
- 최초 적합, 최적 적합, 최악 적합 등

**대치 정책**
- 재배치 기법으로 메인 메모리에 있는 어떤 프로세스를 제거할 것인가를 결정

### 나. 메모리 해석에 대한 두 가지 관점
- 물리적 공간과 논리적 공간으로 구분
  - 물리적 공간(물리적 주소)
    - 실제 데이터나 프로그램이 저장되는 공간
    - 메모리 칩, 디스크 공간으로 생성
    - 사용되는 단위는 바이트(Byte)
    - 논리적 주소보다 크거나, 적거나, 같을 수 있다.

  - 논리적 공간(논리적 주소)
    - 프로그래머가 프로그래밍에 사용하는 공간
    - 목적코드(Object Code) 저장된 공간, 프로그램에서 사용하는 자료구조 등 해당
    - 논리적 메모리 크기는 각 시스템에서 정의한 워드의 길이에 따라 다름

- 메모리 매핑(Memory Mapping)
   - 논리적 주소와 물리적 주소의 연결
   - 메모리 관리 장치(MMU, Memory Management Unit)인 하드웨어에서 실행
   - 메모리 관리 방식에 따라 여러 방식으로 구분
     - 고정 분할
     - 동적 분할
     - 페이징
     - 세그먼트
     - 페이지화된 세그먼트 방식

### 다. 메모리 관리 방식
- 연속 메모리 할당 방식 : 프로그램(프로세스) 적재하는 과정에서 연속적으로 메모리를 할당
- 분산 메모리 할당 방식 : 프로그램을 페이지나 세그먼트 단위로 나누어 여러 곳에 적재하여 할당

**메모리 방식 발전 과정(1/2)**
- 연속 메모리 할당 방식 사용_(초기 컴퓨터 시스템)_
  - 각 프로그램이 연속된 하나의 블록을 차지하도록 할당
  - 직접 배치, 중첩(오버레이), 분할 기법 등이 해당

- 고정 분할 기법
  - 메모리 영역을 여러 개의 고정된 크기로 분할하여 프로세스에 제공하며, 메모리의 낭비(내부 단편화)를 유발

**메모리 방식 발전 과정(2/2)**
- 동적(가변) 분할 기법
  - 각 프로세스의 크기에 따라 메모리를 분할하는 방식으로, 고정 분할 기법의 문제점을 해결하기 위해 제시
  - 다중프로그래밍 기법에 적용하며, 분산 메모리 할당 방식이 제시
- 분산 메모리 할당 방식
  - 사용자의 프로세스가 페이지나 세그멘테이션 등의 단위로 보조기억장치에 적재되어 있다가 프로세스의 요구에 의해 메인 메모리의 여러 영역에 할당되는 방식
  - 현재의 가상 메모리 관리 기법으로 발전

### 라. 주소 바인딩(Binding)
**논리적 주소를 물리적 주소로 변환하는 과정 (1/4)**
- 프로그램에 있어서의 주소를 절대 주소로 바꾸어 메인 메모리의 고정된 부분에 적재
- 방식에 따라 단계별 구분
  - 컴파일(Complie)
  - 적재시간
  - 수행시간

**논리적 주소를 물리적 주소로 변환하는 과정(2/4)**
- 컴파일 : 프로세스가 메모리 내에 적재될 위치를 컴파일 과정에서 알 수 있다면 컴파일러는 물리적 주소를 생성할 수 있다.
- 절대 재배치 : 메인 메모리의 실제 주소로 변환되는 과정 

**논리적 주소를 물리적 주소로 변환하는 과정(3/4)**
- 적재 시간 : 프로세스가 메모리 내의 어디에 적재되어야 할 것인가를 컴파일 과정에서 알려주지 않으면 컴파일러는 재배치 가능 상대 주소를 생성  
상대 주소는 프로그램의 시작 주소가 0으로 생성되므로 최종 바인딩은 적재시간까지 연기  
시작 주소가 변하면 사용자 코드는 변화된 값 반영을 위해 재 적재한다.

**논리적 주소를 물리적 주소로 변환하는 과정(4/4)**
- 수행시간 : 프로세스가 실행되는 도중에 메모리의 한 세그먼트에서 다른 세그먼트로 이동 시 바인딩은 수행시간까지 연기  
현대의 운영체제는 실행시간에 바인딩이 이루어진다.

### 마. 동적 적재(Dynamic Loading)
- 메모리 공간 이용의 효율적 운영을 위해 제안
- 모든 루틴은 호출될 때까지 메모리 내에 적재되지않고 재배치 가능한 형태로 디스크에 저장
- 먼저 주 프로그램은 메모리에 적재되어 수행
- 주 프로그램(호출 루틴)이 다른 루틴을 호출할 필요가 있을 때, 호출 루틴은 호출될 루틴이 메모리에 적재되어 있는지 조사
- 만약 적재되어 있지 않다면, 재배치 기능 연결적재기(로더)는 요구된 루틴을 메모리로 적재하기 위해 호출하면서 프로그램의 주소 테이블을 갱신, 변화를 반영

- 장점
  - 사용하지 않는 루틴을 적재하지 않는다.
  - 코드 양이 많이 필요한 경우 유용
  - 프로그램 전체 양은 많으나 실제로 사용된 구역은 적으며, 운영체제로부터 특별한 자원을 필요치 않음(동적 연결적재기는 제공되어야 함)

### 바. 중첩(Overlay)
- 프로세스의 크기가 실제 메모리 크기로 제한되는 문제점을 해결하기 위해 사용
- 운영체제 영역과 메모리 공간의 일부 영역에 프로그램(작업) 실행에 반드시 필요한 명령어와 데이터를 저장
- 중첩 구동기(오버레이 드라이버)영역에는 실행기간 동안 필요한 각종 사용자 코드 등을 적재하여 필요한 시기에 해당 프로그램을 불어들여 실행 

- 중첩구조
  - 사용자 프로그램을 초기 모듈, 출력 모듈로 구별, 초기 모듈에 적재한 후 실행
  - 처리 모듈을 실행한 후 출력 모듈을 실행
  - 1단계 동안 심볼테이블 작성, 2단계 동안 기계 코드를 생성하는 어셈블러
  - 수행되는 기능이 다른 path1, path2는 동시에 메모리 내에 있을 필요가 없으므로 아래와 같은 두 개의 중첩을 정의하여 사용
  - path 1 : 70KB / path 2 : 80KB
  - 오버레이 드라이버를 추가하여 중첩 a를 시작, path 1이 끝날 때 중첩 b를 메모리로 읽어 드린다. 중첩a에 기록한 다음 제어를 path 2로 옮김

**2단계 어셈블러를 위한 중첩(1/2)**
- 중첩은 프로그래머에 의해 파일들을 메모리로 읽어 들이고, 그 메모리로 분기하여 새로운 읽기 명령을 수행하는 간단한 파일 구조를 사용
- 실행함으로써 운영체제는 평상시보다 더 많은 입출력이 있다는 것만 인식

**2단계 어셈블러를 위한 중첩(2/2)**
- 중첩은 현재 마이크로 컴퓨터나 실제 메모리 크기가 제한된 하드웨어에서 사용
  - 중첩을 이용하려면 프로그래머는 중첩 구조를 적절하게 설계, 프로그래밍 해야하므로 구조와 코드, 자료 구조를 완전히 이해해야한다.
  - 현재 프로그램이 커지는 추세이므로 전체 내용을 충분히 이해하기 어렵다.

### 사. 프로세스 교체 
- 다중프로그래밍 환경에서 프로세스는 사용자 프로그램이 끝날때까지 메인 메모리에 저장
- 순환할당알고리즘 이나 우선순위에 바탕을 둔 프로세스 알고리즘에서 사용하기 적합하지 않다.
- 프로세스 할당이 끝나고 수행이 완료된 프로세스는 보조기억장치로 이동, 새롭게 시작되는 프로세스를 불러와야한다.
  - 프로세서가 수행되기 위해 메모리 내에 위치해야하므로, 일시적으로 보조기억장치로 이동 후 다시 메모리에 적재해야한다.

- 순환 할당 프로세서 스케줄링 알고리즘을 가진 다중프로그래밍환경
- 프로세서에 할당된 시간이 지나면, 메모리관리장치가 방금 끝난 프로세스(p1)을 보조기억장치로 이동, 다른 프로세스(p2)를 사용가능 공간으로 이동

- 프로세스 처리 상태
  - 교체 실행 스케줄러는 디스크(스왑 준비)에 저장된 작업을 메인 메모리로 이동
  - 이동한 작업은 준비 큐에서 실행 대기, 실행 도중 교체 대상이 되면 대기 상태
  - 실행 조건이 만족되면 준비 큐로 이동, 디스크로 이동(스왑 아웃)
  - 스왑 대기 상태의 작업은 실행 조건 만족 시 스왑 준비 상태로 변경

- Roll-in, Roll-out
  - 더 높은 우선순위를 가진 프로세스 도착 시 메모리 관리 장치는 우선순위가 높은 프로세스를 수행하기 위해 낮은 우선 순위의 프로세스와 스왑(교체)가능
  - 높은 우선 순위의 프로세스가 끝나면, 낮은 우선 순위의 프로세스는 다시 스왑되어 계속 수행

- 스왑과정
  - 주소 바인딩 방법에 따라 다르다.
  - 바인딩이 어셈블 시간이나 적재시간에 이루어지면 프로세스는 다른 위치로 이동 불가
  - 수행 시간에 바인딩이 이루어지면 교체 가능

- 교체 시간
  - 속도가 빠른 보조기억장치가 필요하며, 문맥 교환 시간이 중요
  - 사용자 프로세스가 100kb, 보조기억장치는 초당 imb의 전송률을 가진 디스크를 가정
  - 보조기억장치에서 실제 전송은 아래와 같은 시간이 소요
  - 회전 지연 시간을 평균 8ms로 가정했을 때 교체시간은 108ms
  - 효과적인 프로세서 사용을 위해 각 프로세스에 대한 수행시간이 교체시간보다 길어야한다.
