# 메모리 관리(1)
1. 메모리 관리 개념

### 가. 메모리 관리 기법
- 메인 메모리는 운영체제를 위한 영역 중인 프로그램을 위한 영역으로 구분
- 메모리 관리 : 다중프로그래밍 시스템에서 운영체제에 의해 동적으로 메모리의 사용자 영역을 여러 프로세스가 상주할 수 있도록 세분화하는 과정

**반입 정책**
- 메인 메모리에 적재할 다음 프로세스의 반입시기하는 방법
  - 요구 반입 기법 : 운영체제나 시스템 프로그램, 사용자 프로그램 등의 참조 요구에 따라 메인 메모리에 적재 방법으로 오랫동안 사용
  - 예상 반입 기법 : 시스템의 요구를 예측하여 메모리에 미리 적재하는 방법으로 최근 사용되기 시작, 요구되는 페이지 외의 다른 페이지도 함께들임, 탐색시간, 회전 지연 시간을 갖는 보조기억장치의 특성을 참조한 정책

**배치 정책**
- 디스크에 반입한 프로세스를 메인 메모리 어느 위치에 저장할 것인가를 결정하는 방법
- 최초 적합, 최적 적합, 최악 적합 등

**대치 정책**
- 재배치 기법으로 메인 메모리에 있는 어떤 프로세스를 제거할 것인가를 결정

### 나. 메모리 해석에 대한 두 가지 관점
- 물리적 공간과 논리적 공간으로 구분
  - 물리적 공간(물리적 주소)
    - 실제 데이터나 프로그램이 저장되는 공간
    - 메모리 칩, 디스크 공간으로 생성
    - 사용되는 단위는 바이트(Byte)
    - 논리적 주소보다 크거나, 적거나, 같을 수 있다.

  - 논리적 공간(논리적 주소)
    - 프로그래머가 프로그래밍에 사용하는 공간
    - 목적코드(Object Code) 저장된 공간, 프로그램에서 사용하는 자료구조 등 해당
    - 논리적 메모리 크기는 각 시스템에서 정의한 워드의 길이에 따라 다름

- 메모리 매핑(Memory Mapping)
   - 논리적 주소와 물리적 주소의 연결
   - 메모리 관리 장치(MMU, Memory Management Unit)인 하드웨어에서 실행
   - 메모리 관리 방식에 따라 여러 방식으로 구분
     - 고정 분할
     - 동적 분할
     - 페이징
     - 세그먼트
     - 페이지화된 세그먼트 방식

### 다. 메모리 관리 방식
- 연속 메모리 할당 방식 : 프로그램(프로세스) 적재하는 과정에서 연속적으로 메모리를 할당
- 분산 메모리 할당 방식 : 프로그램을 페이지나 세그먼트 단위로 나누어 여러 곳에 적재하여 할당

**메모리 방식 발전 과정(1/2)**
- 연속 메모리 할당 방식 사용_(초기 컴퓨터 시스템)_
  - 각 프로그램이 연속된 하나의 블록을 차지하도록 할당
  - 직접 배치, 중첩(오버레이), 분할 기법 등이 해당

- 고정 분할 기법
  - 메모리 영역을 여러 개의 고정된 크기로 분할하여 프로세스에 제공하며, 메모리의 낭비(내부 단편화)를 유발

**메모리 방식 발전 과정(2/2)**
- 동적(가변) 분할 기법
  - 각 프로세스의 크기에 따라 메모리를 분할하는 방식으로, 고정 분할 기법의 문제점을 해결하기 위해 제시
  - 다중프로그래밍 기법에 적용하며, 분산 메모리 할당 방식이 제시
- 분산 메모리 할당 방식
  - 사용자의 프로세스가 페이지나 세그멘테이션 등의 단위로 보조기억장치에 적재되어 있다가 프로세스의 요구에 의해 메인 메모리의 여러 영역에 할당되는 방식
  - 현재의 가상 메모리 관리 기법으로 발전

### 라. 주소 바인딩(Binding)
**논리적 주소를 물리적 주소로 변환하는 과정 (1/4)**
- 프로그램에 있어서의 주소를 절대 주소로 바꾸어 메인 메모리의 고정된 부분에 적재
- 방식에 따라 단계별 구분
  - 컴파일(Complie)
  - 적재시간
  - 수행시간

**논리적 주소를 물리적 주소로 변환하는 과정(2/4)**
- 컴파일 : 프로세스가 메모리 내에 적재될 위치를 컴파일 과정에서 알 수 있다면 컴파일러는 물리적 주소를 생성할 수 있다.
- 절대 재배치 : 메인 메모리의 실제 주소로 변환되는 과정 

**논리적 주소를 물리적 주소로 변환하는 과정(3/4)**
- 적재 시간 : 프로세스가 메모리 내의 어디에 적재되어야 할 것인가를 컴파일 과정에서 알려주지 않으면 컴파일러는 재배치 가능 상대 주소를 생성  
상대 주소는 프로그램의 시작 주소가 0으로 생성되므로 최종 바인딩은 적재시간까지 연기  
시작 주소가 변하면 사용자 코드는 변화된 값 반영을 위해 재 적재한다.

**논리적 주소를 물리적 주소로 변환하는 과정(4/4)**
- 수행시간 : 프로세스가 실행되는 도중에 메모리의 한 세그먼트에서 다른 세그먼트로 이동 시 바인딩은 수행시간까지 연기  
현대의 운영체제는 실행시간에 바인딩이 이루어진다.

### 마. 동적 적재(Dynamic Loading)
- 메모리 공간 이용의 효율적 운영을 위해 제안
- 모든 루틴은 호출될 때까지 메모리 내에 적재되지않고 재배치 가능한 형태로 디스크에 저장
- 먼저 주 프로그램은 메모리에 적재되어 수행
- 주 프로그램(호출 루틴)이 다른 루틴을 호출할 필요가 있을 때, 호출 루틴은 호출될 루틴이 메모리에 적재되어 있는지 조사
- 만약 적재되어 있지 않다면, 재배치 기능 연결적재기(로더)는 요구된 루틴을 메모리로 적재하기 위해 호출하면서 프로그램의 주소 테이블을 갱신, 변화를 반영

- 장점
  - 사용하지 않는 루틴을 적재하지 않는다.
  - 코드 양이 많이 필요한 경우 유용
  - 프로그램 전체 양은 많으나 실제로 사용된 구역은 적으며, 운영체제로부터 특별한 자원을 필요치 않음(동적 연결적재기는 제공되어야 함)

### 바. 중첩(Overlay)
- 프로세스의 크기가 실제 메모리 크기로 제한되는 문제점을 해결하기 위해 사용
- 운영체제 영역과 메모리 공간의 일부 영역에 프로그램(작업) 실행에 반드시 필요한 명령어와 데이터를 저장
- 중첩 구동기(오버레이 드라이버)영역에는 실행기간 동안 필요한 각종 사용자 코드 등을 적재하여 필요한 시기에 해당 프로그램을 불어들여 실행 

- 중첩구조
  - 사용자 프로그램을 초기 모듈, 출력 모듈로 구별, 초기 모듈에 적재한 후 실행
  - 처리 모듈을 실행한 후 출력 모듈을 실행
  - 1단계 동안 심볼테이블 작성, 2단계 동안 기계 코드를 생성하는 어셈블러
  - 수행되는 기능이 다른 path1, path2는 동시에 메모리 내에 있을 필요가 없으므로 아래와 같은 두 개의 중첩을 정의하여 사용
  - path 1 : 70KB / path 2 : 80KB
  - 오버레이 드라이버를 추가하여 중첩 a를 시작, path 1이 끝날 때 중첩 b를 메모리로 읽어 드린다. 중첩a에 기록한 다음 제어를 path 2로 옮김

**2단계 어셈블러를 위한 중첩(1/2)**
- 중첩은 프로그래머에 의해 파일들을 메모리로 읽어 들이고, 그 메모리로 분기하여 새로운 읽기 명령을 수행하는 간단한 파일 구조를 사용
- 실행함으로써 운영체제는 평상시보다 더 많은 입출력이 있다는 것만 인식

**2단계 어셈블러를 위한 중첩(2/2)**
- 중첩은 현재 마이크로 컴퓨터나 실제 메모리 크기가 제한된 하드웨어에서 사용
  - 중첩을 이용하려면 프로그래머는 중첩 구조를 적절하게 설계, 프로그래밍 해야하므로 구조와 코드, 자료 구조를 완전히 이해해야한다.
  - 현재 프로그램이 커지는 추세이므로 전체 내용을 충분히 이해하기 어렵다.

### 사. 프로세스 교체 
- 다중프로그래밍 환경에서 프로세스는 사용자 프로그램이 끝날때까지 메인 메모리에 저장
- 순환할당알고리즘 이나 우선순위에 바탕을 둔 프로세스 알고리즘에서 사용하기 적합하지 않다.
- 프로세스 할당이 끝나고 수행이 완료된 프로세스는 보조기억장치로 이동, 새롭게 시작되는 프로세스를 불러와야한다.
  - 프로세서가 수행되기 위해 메모리 내에 위치해야하므로, 일시적으로 보조기억장치로 이동 후 다시 메모리에 적재해야한다.

- 순환 할당 프로세서 스케줄링 알고리즘을 가진 다중프로그래밍환경
- 프로세서에 할당된 시간이 지나면, 메모리관리장치가 방금 끝난 프로세스(p1)을 보조기억장치로 이동, 다른 프로세스(p2)를 사용가능 공간으로 이동

- 프로세스 처리 상태
  - 교체 실행 스케줄러는 디스크(스왑 준비)에 저장된 작업을 메인 메모리로 이동
  - 이동한 작업은 준비 큐에서 실행 대기, 실행 도중 교체 대상이 되면 대기 상태
  - 실행 조건이 만족되면 준비 큐로 이동, 디스크로 이동(스왑 아웃)
  - 스왑 대기 상태의 작업은 실행 조건 만족 시 스왑 준비 상태로 변경

- Roll-in, Roll-out
  - 더 높은 우선순위를 가진 프로세스 도착 시 메모리 관리 장치는 우선순위가 높은 프로세스를 수행하기 위해 낮은 우선 순위의 프로세스와 스왑(교체)가능
  - 높은 우선 순위의 프로세스가 끝나면, 낮은 우선 순위의 프로세스는 다시 스왑되어 계속 수행

- 스왑과정
  - 주소 바인딩 방법에 따라 다르다.
  - 바인딩이 어셈블 시간이나 적재시간에 이루어지면 프로세스는 다른 위치로 이동 불가
  - 수행 시간에 바인딩이 이루어지면 교체 가능

- 교체 시간
  - 속도가 빠른 보조기억장치가 필요하며, 문맥 교환 시간이 중요
  - 사용자 프로세스가 100kb, 보조기억장치는 초당 imb의 전송률을 가진 디스크를 가정
  - 보조기억장치에서 실제 전송은 아래와 같은 시간이 소요
  - 회전 지연 시간을 평균 8ms로 가정했을 때 교체시간은 108ms
  - 효과적인 프로세서 사용을 위해 각 프로세스에 대한 수행시간이 교체시간보다 길어야한다.

- 두 가지 문제의 해결방법
  - 대기 입출력을 가진 프로세스는 교체를 수행하지 않고, 입출력 동작이 있는 운영체제의 버퍼 내에서만 교체를 수행
  - 운영체제와 프로세스 메모리 사이의 전송은 프로세스가 교체되어 들어올 때만 이루어져야한다.

2. 연속 메모리 할당

### 가. 연속 메모리 할당 개념
- 초기 컴퓨터 시스템에 적용한 메모리 관리기법
  - 실행될 모든 프로그램은 필요한 영역만큼 연속적인 메모리 공간을 할당받아 메모리에 적재
  - 한번에 적재 불가능하면 실행이 불가능하므로, 프로그램 수정 및 작은 모듈로 구성

### 나. 단일 사용자 연속 메모리 할당
- 메모리 영역을 사용자를 위한 공간과 운영체제 상주를 위한 공간 구분
  - 운영체제를 메모리의 하위, 상위에 두는 것이 가능
  - 메모리를 운영체제 루틴이 들어있는 부분(모니터)과 사용자프로그램이 들어있는 부분(사용자)
  - 사용자가 모든 메인 메모리에 대한 제어권을 가짐
    - 운영체제 파괴를 막기위해 프로세서 내에 경계 레지스터를 둔다.
    - 사용자프로그램이 메모리 주소를 참조할 때마다 경계 레지스터를 검사한 후 실행

- 문제점
  - 사용자 프로그램의 적재
    - 컴퓨터 주소 공간이 0000 부터 시작하더라도 사용자프로그램의 처음 주소는 0000번지가 아니라 기준 레지스터 값 이후가 되므로, 기준 주소가 변하면 다시 적재해야한다.

- 해결방법
  - 사용자프로그램을 기준으로 상위 주소에 적재하지 않고 기준 레지스터로부터 내려가는 상위 메모리에 적재 
  - 사용되지 않은 모든 공간이 중간에 있고, 운영체제나 사용자는 필요에 따라 사용되지 않은 공간으로 확정 가능 
  - 수행할 때 까지 바인딩을 연기
    - 동적 적재를 위한, 주소 바인딩을 연기하기 위한 기준 레지스터(재배치 레지스터)가 필요
    - 기준 레지스터에 있는 값은 사용자 프로세스가 메모리로 보내질 때 생성되는 주소값에 더해진다.
    - 기준값이 1400일 경우, 주소 0에 대한 사용자 프로세스는 동적으로 1400으로 재배치, 주소 346에 대한 접근은 1746으로 재배치 

- 교체 기법
  - 메인 메모리보다 더 큰 프로그램을 실행할 수 있으므로 제한된 메인 메모리를 확장시키는 방법으로 사용된다.
  - 단일 사용자 연속 메모리 할당 시스템이 프로세서 중심 작업일 경우
    - 프로세스를 집중적으로 사용 가능
    - 입출력 작업이 교대로 발생하는 경우에 프로세서의 유휴 상태가 자주 발생

### 다. 고정 분할 다중프로그래밍
- MFT(Multiprogramming with a Fixed number of Tasks)
  - IBM OS/360에서 사용되었으나, 현재는 사용되지않음
  - 고정된 크기의 분할 영역에 프로세스(작업)가 각각 할당
  - 물리 주소는 분할 기준  레지스터(PBR) 값에 논리 주소를 더하여 생성
    - 논리 주소가 분할 영역 크기보다 크면 오류 발생
    - 분할 영역보다 프로세스의 크기가 대부분 작으므로 내부 단편화가 발생
  - 분할의 수에 고정 분할 다중프로그래밍의 성능이 제한 
    - 분할 영역이 비면 프로세스는 프로세스 큐에서 하나를 선택하여 빈 분할에 적재
    - 프로세스의 작업이 끝나면 그 분할은 다른 프로세스가 이용 가능

- 다중프로그래밍의 성능 향상을 위해 다음 사항을 결정
  - 분할 영역의 크기
    - 시스템 부하를 분석, 영역의 개수와 크기를 결정
    - 영역의 개수는 다중프로그래밍의 정도가 될 수 있으며, 영역의 크기 결정은 시스템 전체의 효율을 나타낸다.
  - 영역의 배경
    - 프로그램 작업을 어느 영역에 배정하는 지에 대한 결정
    - 결정을 위해 작업 스케줄러가 필요

### 라. 고정 분할 다중프로그래밍에서의 단편화
- 메모리의 단편화(Fragmentation)는 메모리 구성과 관계없이 모든 컴퓨터 시스템에서 발생
  - 사용자 작업의 크기가 지정된 분할에 정확히 맞지 않거나 분할이 너무 작아서 대기 중인 작업 중 하나도 맞는 것이 없는 상태
  - 분할된 공간은 사용되지 않고 남아 내부 단편화의 원인

- 다수의 영역을 할당한 메모리 영역
  - 18,464byte의 사용가능 공간이 있을 때 프로세스가 18,462byte를 요구한다 가정
  - 요구된 블록을 정확히 할당하면 2byte의 사용가능 공간이 남는다.
  - 남은 2byte의 사용가능 공간을 활용하기 위한 처리비용은 사용가능 공간을 활용하는 비용보다 크다.
  - 이러한 부분을 내부 단편화라고 부르며, 대부분 사용할 수 없는 공간

- 내부 단편화
  - 단편화는 작업 스케줄러와 분할의 크기에 의해 좌우
    - 메모리의 낭비를 가져오므로 어떤 분할에서도 실행 가능한 재배치 기능 프로그램을 만들어야한다.
    - 고정 분할은 효율적인 메모리 운영이 가능하나 기억 장소의 낭비가 있다.
    - 메모리에 상주해야하는 프로세스들이 있으므로 메모리 보호가 필요하다.

- 고정분할에서의 메모리 보호
  - 두 개의 레지스터(기준 레지스와 한계 레지스터)를 사용하여 분할된 영역 보호
    - 기준 레지스터 : 가장 작은 합법적인 물리 메모리 주소 (30040) 저장
    - 한계 레지스터 : 프로그램 영역이 저장되어있는 범위의 크기(120900) 저장
  - 프로세서의 의해 생성된 모든 주소는 레지스터와 함께 검사되므로 다른 사용자의 프로그램과 데이터를 보호할 수 있다.

### 마. 가변 분할 다중프로그래밍(MVT, Mulitprogramming with a Varable number of Tasks)
- 고정된 경계를 없애고 각 작업이 필요한 만큼만 메모리를 할당
  - 각 프로세스(분할 영역)을 나타내기 위해 기준 (재배치) 레지스터와 한계 레지스터를 사용
  - 한계 레지스터는 프로세스 크기만큼의 영역에 저장
    - 프로세서에 의해 생성된 논리 주소가 한계 레지스터 값보다 크면 오류 발생

- 분할 테이블에 있는 p3의 경우 한계 레지스터(250), 기준 레지스터(5034)와 매핑, 물리 메모리 공간에 저장
- 운영체제는 메모리의 사용내역을 확인할 수 있는 테이블을 유지해야한다.
  - 256kb의 이용할 수 있는 메모리와 40kb 크기의 운영체제 그리고 작업 큐에 아래와 같이 작업을 가진다 가정.

- 운영체제는 메모리의 사용내역을 확인할 수 있는 테이블을 유지해야한다.
  - 작업1 (60kb), 작업2(100kb), 작업3(30kb)에 메모리를 할당하여 기억장소 작성
  - 5시간 후 작업2가 종료되면서 사용했던 메모리 할당량을 해제
  - 작업4가 스케줄되어 할당
  - 작업1이 10시간 후에 종료되면 메모리가 해제
  - 작업5에 메모리 할당

- 가변 분할(동적 메모리 할당)은 요구된 크기 n을 사용가능 공간에 어떻게 할당하느냐의 문제
  - 최초 적합(First-fit), 최상 적합, 최악 적합

### 바. 메모리 재배치 기법
- 최초 적합 기법
  - 프로세스는 사용 가능 공간 리스트에서 충분히 큰 첫 번째 분할 공간에 할당
  - 검색은 사용 가능 공간 리스트의 맨 앞에서 시작하거나 이전의 최초 적합 검색이 끝났던 곳에서 시작
  - 검색은 빠르나 공간 활용율이 떨어진다.

- 최상 적합 기법
  - 프로세스가 들어갈 수 있는 충분히 큰 사용 가능 공간 중에서 가장 작은 크기의 사용 공간에 작업을 할당
  - 사용 가능 공간에 대한 지속적인 정렬 과정이 필요하여 비 효율적
    - 공간 리스트가 크기 순서로 정렬 되어 있지 않을 시 전 리스트를 검색해야 한다.
  - 사용 가능 공간 이용률은 향상 되나 할당되는 과정에 많은 시간이 소요
  - 가장 작은 또 다른 사용 가능 공간 생성 가능

- 최악 적합 기법
  - 작업을 가장 큰 사용 가능 공간에 할당
  - 공간이 크기 순서로 정렬 되어 있지 않을 시 전 리스트를 검색해야한다.
  - 최상 적합보다 메모리 활용면에서 더 유용

### 아. 외부 단편화
- 가변 분할 알고리즘은 외부 단편화 문제 발생
  - 프로세스들이 메모리에서 제거되고 새로운 프로세스가 적재될 때, 사용 가능 공간은 작게 나누어진다.
  - 프로세스들이 연속된 메모리를 차지하는 과정에서 공백이 발생, 사용 가능 공간은 많은 수의 작은 공가능로 단편화될 수 있다.
  - 분할은 프로세스가 요구한 크기로 만들어지므로 내부 단편화는 거의 없으나 외부 단편화는 발생할 수 있다.

- 통합
  - 하나의 작업이 끝났을 때, 기억 장소가 비어있는 다른 기억 장소(공백)와 연결되어 있는지를 점검, 하나의 공백으로 합하는 과정
  - 통합 과정을 수행하더라도 메모리 전반에 흩어져 있는 비어있는 공간을 모두 사용 가능 공간으로 통합하기 어려움

- 압축
  - 메모리 내용들을 적절히 움직여 모든 사용 가능 메모리를 하나의 큰 블록으로 만듦
  - 압축 과정 : 메모리 랩 중 10kb, 30kb, 26kb의 사용 가능 공간을 66kb의 하나의 공간으로 통합 확장

- 압축은 항상 가능하지 않다.
  - 작업3과 작업4를 이동
  - 이동한 작업 프로세스들이 새로운 위치에서 수행되기위해 모든 내부 주소들이 재배치되어야 한다.
  - 재배치가 정적이면서 어셈블리나 적재할 때 실행될 경우 불가능하다.

- 압축 방법에 따라 비용이 많이 든다.
  - 작업3과 작업4를 위해 총 600kb를 이동, 또는 작업3을 작업4 밑으로 이동해 200kb를 이동시킬 수 있다.
  - (d)에서 사용가능한 하나의 큰 메모리 공간이 가운데 있으며, 큐가 450kb를 요구하는 한 프로세스만을 가진 경우 작업2를 다른 위치로 이동시켜 요구 만족 시킨다.

- 장점
  - 가변 메모리에서 발생하는 수 많은 적은 공간을 하나의 큰 공백으로 변환, 새로운 작업에 할당 가능 

- 단점
  - 압축할 동안 시스템은 모든 일을 멈추어야 한다.
  - 메모리에 있는 작업들을 이동시켜야하므로 프로그램 적재 시 제거되는 재배치 관련 정보를 액세스 가능한 형태로 보관해야 한다.
  - 압축 작업이 자주 요구되어 시스템 자원 소모가 크다.

### 자. 버디 시스템(Buddy System)
- 자원 할당 과정에서 발생하는 단편화 문제를 해결하기위해 제안
  - 큰 버퍼들을 반복적으로 이등분하여 작은 버퍼 생성
  - 가능할 때마다 인접한 자유로운 버퍼들(Free Buffers)을 합치는 과정을 반복
  - 버퍼가 나뉘어 질 때, 각각을 서로의 버디(Buddy)라고 부른다.
  - 사용할 수 있는 메모리 블록(k)은 ㅣ < ㅏ < u 로 나타낸다.
    - L : 할당 가능한 가장 작은 블록
    - U : 가장 큰 블록으로 전체 메모리를 말한다.

  - 요청된 메모리의 크기가 작아 전체를 할당하지 않을 경우, 블록은 2U-1의 크기를 갖는 2개의 버디로 나누어진다.
  - 이 과정을 반복하여 요청된 크기와 같거나 큰 블록 생성, 요청이 할당될 때까지 계속된다.
  - 한 커널은 크기가  b인 빈 버디 블록 쌍을 크기가 2b인 더 큰 블록 하나로 합친다.

- 크기가 64kb의 초기 블록을 사용한 예)
  - 8kb, 8kb, 4kb의 크기로 세 작업이 요청된다 가정
