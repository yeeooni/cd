# 파일 관리(1)

- 개요

  - 파일 자원을 관리하고 파일의 생성, 삭제 등 파일 액세스 및 제어에 대한 책임을 갖는 소프트웨어
  - 파일의 저장 위치, 저장 방법, 저장 공간 활용, 파일 사용 할당, 파일 접근 횟수 등과 관련된 복잡한 작업 수행
  - 작업 수행을 위해 각 파일에 대한 정보를 수록한 디렉터를 사용하여 해당 파일을 관리
  - 디스크 저장소를 관리하는 것과 관련이 많다.
  - 메인 메모리 및 다른 매체에 저장된 파일 데이터 액세스 포함
  - 사용자가 파일을 생성, 수정, 삭제할 수 있도록 지원
  - 파일이 각 응용프로그램에 적합한 구조로 구성할 수 있도록 지원
  - 파일 읽기, 쓰기, 실행 등이 다양하게 액세스 되도록 제어된 방식 제공
  - 설계를 위해 사용자 수, 사용자 당 평균 파일 수와 크기 등 사용자들에 관한 지식 필요
  - 해당 시스템에서 실행할 응용 프로그램의 특성을 이해, 적합한 파일 구성과 디렉터리 구조를 결정

- 기능

  - 파일 관리
  - 보조 메모리 관리
  - 파일 무결성 보장
  - 파일 액세스 방법
  - 파일 백업과 복구
  - 사용자가 각 응용 업무 처리에 적합한 구조로 파일을 구성
  - 사용자가 파일 간의 정보 전송 명령을 내릴 수 있게 한다.
  - 다양한 형태의 저장 장치를 위한 입출력 지원
  - 사용자가 물리적 장치 이름을 사용 하는 대신 기호화된 이름을 사용하여 자신의 파일을 참조하여 장치와의 독립성을 유지
  - 정보 보호와 비밀 보장을 위해 파일 시스템은 정보를 암호화 하고 해독할 수 있는 능력을 갖추어야한다.
  - 사용자는 파일의 생성과 삭제 파일에 대한 연산 수행을 위해 파일 시스템과 상호 작용
  - 모든 파일의 위치와 파일의 속성을 기술하는 디렉터리 사용
  - 기본연산 (생성, 기록, 판독, 삭제) 들을 레코드 수준에서 수행
  - 파일의 레코드들은 출력을 위해 블록화 되어야 하며 입력 후에 블록이 해제되어야한다.
  - 디스크 스케줄링과 더불어 파일 할당은 성능의 최적화 관계 있다.

- 구조

  - 파일의 정의, 속성, 디렉토리 구조, 파일에 허용되는 연산 등을 표현하는 논리적 파일과 실제 디스크에 논리 파일 시스템을 사상하는 것으로 구분한다.

- 블록

  - 파일은 디스크의 하나 이상의 블록에 저장, 블록은 메모리와 디스크 간의 전송 단위
  - 디스크에 하나 이상의 섹터들로 구성, 블록 할당 방법은 운영체제에 따라 다르다.
  - 운영체제는 파일에 속하는 정보를 블록에 유지하며 0에서 시작하는 연속 정수를 통해 일부 최대수에 이르는 논리 블록 번호를 사용한다.
  - 논리 블록 번호는 물리적 디스크 주소(트랙, 실린더, 표면, 섹터)로 변환
    - 변환은 장치 드라이버가 수행하며 디스크 제어기에 낮은 수전의 하드웨어 명령어로 전달
  - 논리적 파일의 물리적 장치로의 사상
    - 가상 블록 번호(VBN, Virtual Bock Number) 즉 논리적 파일을 파일 시스템에 의해 논리 블록 번호(LBN, Logical Block Number) 물리적 파일로 사상하는 과정

- 메타 데이터

  - 저장 장치의 가용 블록 위치나 파일이 마지막으로 수정된 시간 등 여러 데이터를 포함한 데이터
  - 파일 시스템에 대한 크기, 가용 공간, 루트 데이터 위치, 가용 리스트 등의 정보와 파일에 대한 소유자, 크기, 블록 위치, 액세스 시간 등의 정보를 가진다.
  - 사용자가 직접 수정할 수 없으므로 파일 시스템의 무결성을 유지

- 마운팅

  - 시스템에서 새로운 파일 시스템을 사용하기 위해, 파일 시스템이 미리 제공된 파일 시스템의 디렉터리에서 설치되는 절차
  - 운영체제는 여러 파일 시스템을 마운트 할 수 있는 기능을 제공
  - 여러 파일 시스템을 단일 파일 시스템에서 식별할 수 있는 파일 집합으로 결합
    - 운영체제에 마운트 하려는 파일 시스템의 저장 위치(장치 이름)와 새로운 파일 시스템의 설치지점, 즉 마운트 포인트를 제공함으로써 이루어진다.
  - 마운트 테이블 사용, 마운트 된 디렉터리 관리
    - 마운트 테이블은 마운트 지점 경로명과 마운트 된 각 파일 시스템을 저장하고 있는 장치에 관한 정보를 포함한다.
    - Mount 명령을 이용, 새로운 파일 시스템(/dev/sda6)을 초기 파일 시스템의 /mnt/로 액세스 할 수 있도록 마운트 하는 과정
    - 초기 파일 시스템의 디렉터리 이름 앞에 /mnt을 삽입한 경로명(mnt/dir1, mnt/dir2)을 사용
    - 신규 파일 시스템(/dev/sda6)에 액세스 할 수 있다.
    - 파일 시스템이 마운트 되어 있으면, 사용자는 해당 파일 시스템이 다시 언마운트 될 때까지 마운트 지점에 있든 디렉토리의 내용을 사용할 수 없다.

- 파일 개념

  - 서로 관계 있는 정보의 집합체, 레코드들의 집합체
  - 작성자에 의해 정의된 많은 종류의 서로 다른 형태의 정보, 즉 원시 프로그램, 목적 프로그램, 숫자, 데이터, 텍스트, 도형 이미지, 소리 등이 기록
  - 사용 목적에 따라 특별한 구조를 지닌다.

- 파일 구성

  - 파일 내용은 운영체제에 의해서 물리적 장치에 저장
  - 사용자의 관점에서 파일은 논리적으로는 저장 되는 기본 단위로서 프로그램과 데이터를 가질 수 있다.
  - 논리적 파일을 실제 저장 장치로 매핑 시키는 작업은 운영체제가 담당한다.

- 파일 이름 명명

  - 심볼릭 이름을 사용하여 파일을 참조(조회)하며, 유일한 이름이어야한다.
  - 파일은 루트 디렉터리로부터 각 트리 구조에 도달하는 경로를 따라 위치한다.
  - 특정 파일을 위한 경로명은 디렉터리 이름과 파일의 이름으로 구성한다.

- 파일 속성

  - 다음과 같은 속성(파일 관련 정보를 기술하는 항목) 들을 제공한다.
  - 파일 이름 : 사용자들이 이해할 수 있는 형태로 붙여진다.
  - 파일 타입 : 다양한 파일 형식을 지원하는 시스템의 경우 필요
  - 저장 위치 : 파일이 저장된 장치와 그 장치 위치에 대한 포인터
  - 파일 크기 : 파일의 현재 크기와 경우에 따라 최대 허용 가능한 크기도 포함한다.
  - 액세스 제어 데이터 : 파일 읽기, 쓰기, 실행 등 권한(액세스) 제어에 관한 정보
  - 소유자 : 파일 최초 생성자
  - 레코드 크기 : 고정된 크기 or 최대 크기 등 레코드 종류에 따라 다르다.
  - 시간, 날짜, 사용자 식별 정보 : 생성 시간, 수정 변경 시간, 최근 사용된 시간들을 유지, 이들 정보는 파일의 보호, 보안 및 사용자 감시를 위해 사용

- 파일 구조

  - 파일을 구성하는 레코드들이 보조기억장치에 배치되는 방식
  - 순차 파일
    - 레코드는 고정된 크기는 같은 수의 필드로 구성, 물리적 구성, 물리적 순서에 따라 저장
    - 순차 파일 구조는 테이프 장치 뿐만 아니라 디스크에 쉽게 저장 되는 유일한 구조
    - 파일의 순차적 탐색으로 레코드에 대한 액세스가 지연될 수 있으며, 레코드 추가가 어렵다.
    - 순차 파일을 연결 리스트로 구성, 레코드 추가를 포인터 조작으로 해결 가능하나 부가적인 오버헤드 발생
  - 인덱스 파일
    - 순차 파일의 단점 극복을 위해 인덱스 순차 파일을 구성, 단일 (키) 필드를 기반으로 순차적으로 구성
    - 순차 파일의 특성을 유지하므로 키 필드 외에 다른 속성으로 검색이 필요한 경우 적합하지 않다.
    - 유연성을 제공하기 위한 파일 구조로 순차성과 단일 키의 개념을 없애고 레코드 자신의 인덱스를 통해 참조하는 방법
    - 레코드는 각 레코드의 키에 따라 논리적 순서대로 배열, 시스템은 일부 주요 레코드의 실제 주소가 저장된 인덱스를 관리한다.
    - 인덱스 유형은 완전 인덱스와 부분 인덱스가 존재
      - 완전 인덱스 : 파일에 있는 레코드들을 위해 하나의 항목을 포함, 순차 파일로 구성
      - 부분 인덱스 : 찾고자 하는 필드가 포함된 레코드를 위한 항목을 가르킨다.
    - 가변 길이 레코드에서 어떤 레코드는 필드를 포함하지 않으므로 새로운 레코드가 파일에 추가되면 모든 인덱스 파일을 갱신한다.
  - 파일 구조
    - 파일 내의 레코드들은 일정한 순서를 유지할 필요가 없으며, 레코드 중 특정 항목을 키로 하여 기억 가능한 주소 계산, 이 주소에 레코드를 기억 시킨다.
    - 키 값이 순차적으로 되어 있는 경우 보다 그렇지 않은 경우가 많아, 별도의 주소 계산 루틴을 만들고 이 루틴을 통해서 주소를 생성하는 방법을 사용한다.
    - 레코드의 키를 입력하면 해싱함수에 의해 주소가 계산, 물리적인 기억장치의 기억 장소에 대응한다.
  - 분할된 파일
    - 여러 개의 순차 서브 파일로 구성된 파일
    - 파일을 구성하는 각각의 순차 서브 파일을 맴버라 하며, 각 맴버의 시작 주소는 파일의 디렉터리에 저장한다.
    - 프로그램 라이브러리, 매크로 라이브러리를 저장할 때 사용한다.

- 파일에 대한 연산

  - 파일 생성
    - 파일 생성을 위해 2 단계 필요
    - 파일을 위해 파일 시스템에 있는 공간을 발견
    - 새로 생성한 파일에 대한 항목을 디렉터리에 만들어 파일의 이름과 파일 시스템 내의 위치를 기록
  - 파일 기록
    - 파일명과 파일에 기록할 정보를 표시하는 시스템 호출을 수행
    - 파일명이 주어지면 시스템은 파일의 위치를 알기 위해 디렉터리를 탐색
    - 디렉터리 항목에는 파일의 현재 블록에 대한 포인터를 기록, 이 포인터를 사용하여 다음 블록의 주소를 계산하고 정보를 기록할 수 있다.
    - 기록 포인터는 갱신된다.
  - 파일 판독
    - 파일은 판독되거나 기록되므로 두 개의 포인터(판독 포인터, 기록 포인터)를 가질 수 있다.
    - 대부분의 시스템은 하나의 현재 파일 포인터를 가진다.
    - 판독과 기록 동작은 포인터를 사용한다. 디렉터리 항목 내의 공간을 절약하고 시스템의 복잡성을 감소시킨다.
  - 파일 재설정
    - 현재의 파일 포인터를 조정
    - 포인터 값만 바꾸는 것이므로 실제적인 입출력은 필요 없다.
    - 디렉터리가 탐색되면 현재 파일 위치는 파일의 첫 부분으로 재설정된다.
  - 파일 삭제
    - 파일을 삭제하기 위해 지명된 파일을 디렉터리에서 탐색
    - 관련 디렉터리 항목 발견 시, 해당 파일의 모든 공간을 해제시키고 디렉터리 항목을 무효화시킨다.
    - 해당 파일 공간은 다른 파일이 재사용 가능하다.
  - 파일 크기 조절
    - 파일의 크기를 변경하는 작업
    - 이 외, 파일 편집, 내용 수정, 복사 작업 가능
    - 파일은 이름이 부여된 객체이므로 현존하는 파일에 다시 이름 부여 가능하며, 목적 코드 형태의 파일은 실행 가능

- 테이프 기반의 파일 시스템

  - 초기에 각각의 테이프 장치에 각 파일이 별도로 저장
  - 통계 데이터 등 큰 파일의 경우 데이터 저장을 위해 여러 개의 테이프가 소요 
  - 다중 릴 또는 다중 볼륨테이프 파일의 시스템을 운영체제에서 제공해야한다.
  - 테이프 장치는 사용 효율을 높이기 위해 한 테이프에 여러 파일을 저장 운영하였으며, 이를 위해 디렉터리라는 개념을 적용
    - 디렉터리는 테이프 상의 각 파일의 이름과 위치에 관한 정보를 가진다.
    - 크기 등의 정보를 추가할 수 있으므로 파일에 대한 요약 정보를 유지할 수 있는 편리한 개념
  - IRM 시스템에서는 테이프 릴을 볼륨으로 디렉터리를 VTOC(Volume of Table of Content)라 부른다.

- 파일의 위치를 나타내기 위한 장치 디렉터리로 가진다.

  - 디렉터리는 파일의 이름에 의해 배열, 디스크 내의 위치, 길이, 형태, 소유자, 작성일, 최근의 사용일 등의 정보를 포함한다.
  - 디스크 블록은 재기록이 가능하므로 디렉터리를 변경할 필요가 있을 때는 디렉터리를 읽어 들이고 갱신, 재기록 할 수 있다.

- 레코드 블로킹

  - 디스크 시스템
  - 섹터 크기에 의해 결정되는 블록이 정의되어 있다.
  - 모든 디스크 입출력은 블록 단위, 모든 블록의 크기는 동일

- 테이프 시스템

  - 소프트웨어에 의해 물리적으로 블록의 크기를 정의
  - 레코드당 80문자를 지정하면 레코드 간의 간격을 낭비, 수천바이트를 물리적 레코드로 지정, 테이프의 사용률을 높인다.

- 논리적 레코드는 가변적일 수 있으며, 이는 여러개의 논리적 레코드를 물리적 블록에 패킹함으로 해결 가능하다.

  - 비 블록화 레코드로 구성된 파일
    - 물리적 레코드(섹터)가 단 하나의 논리 레코드로 이루어져 있는 파일
  - 블록화된 레코드로 구성된 파일
    - 여러 개의 논리 레코드가 모여 하나의 물리적 레코드(섹터)를 이루는 파일
  - 고정 길이 레코드로 구성된 파일에서 모든 레코드의 길이가 같으며 블록의 크기는 일반적으로 레코드 크기의 정수 배
  - 가변 길이 레코드로 된 파일에서의 레코드는 길이가 다영하며 최대 크기는 블록의 크기
  - 디스크 공간을 블록 단위로 할당할 경우 내부 단편화 발생
  - 대부분의 시스템에서는 고정된 크기의 블록을 사용, 입출력과 메모리에 버퍼를 할당하므로 디스크에 블록을 구성하는 절차가 간단하다.

- 고정 블로킹

  - 고정된 길이의 레코드를 사용, 한 블록에 필요한 레코드를 저장
  - 블록의 마지막 부분의 일부가 블록의 크기가 제한적으,로 빈 공간이 발생할 수 있다.
  - 신장된 가변 길이 블로킹
    - 고정 블로킹에서 발생하는 빈 공간을 채우도록 가변 길이 레코드가 인접한 블록에 걸쳐 저장
    - 포인터를 이용하여 레코드가 다음 블록에 계속됨을 알린다.
    - 구현과 판독이 어렵다
  - 비 신장된 가변 길이 블로킹
    - 가변 길이 레코드가 사용하나 인접한 두 블록에 나누어 저장하지 않는다.
    - 레코드의 크기를 블록의 크기로 제한하고 메모리의 낭비를 가져올 수 있다.

- 액세스 방법

  - 파일은 정보를 저장, 저장된 정보는 액세스 되어 컴퓨터 메모리에 저장
  - 액세스 : 컴퓨터 메모리에 저장된 데이터를 찾아서 가져오는 과정

- 순차 액세스

  - 파일에 있는 정보는 레코드 단위의 순서로 처리되는 것이 일반적
  - 파일에서 대부분의 동작은 읽기와 쓰기
    - 읽기 동작은 파일의 다음 부분을 읽은 후 자동적으로 파일 포인터를 증가
    - 기록은 파일의 끝에 추가, 기록된 내용의 끝으로 포인터는 이동
  - 파일은 시작 위치로 재설정 될 수 있고, 어떤 시스템에서 프로그램은 정수 n개의 레코드를 앞뒤로 건너뛸 수 있다.

- 직접 액세스

  - 어떠한 블록도 직접 읽거나 쓸 수 있으며, 읽기나 기록은 순서가 없다.
  - 직접 액세스 파일 블록에 직접 읽고 쓸 수 있으며, 읽기나 기록의 순서에 제약이 없다.

  

  

- 디렉터리 시스템

  - 기호 테이블로 구성되며 두 개의 분리된 디렉터리 구조
    - 장치 디렉터리 : 각 실제 장치에 저장되어 있으며 장치에 있는 파일의 물리적 속성등을 나타낸다.
    - 파일 디렉터리 : 모든 파일의 논리적 구성으로 이름, 파일 유형, 소유하고 있는 사용자, 계정 정보, 보호 액세스 코드 등 기술
  - 개요
    - 장치 디렉터리는 단일 사용자 시스템에서는 충분 하나, 저장 공간의 양과 사용자 수가 증가하면 사용자 들은 모든 파일에 대한 구성과 추적이 어려워진다.
    - 이를 해결하기 위해 다른 디렉터리 구조를 추가, 파일들을  구성
  - 디렉터리
    - 파일 시스템에서 다른 파일들의 이름과 위치 정보를 담고 있는 파일, 사용자 데이터 저장안한다.
    - 장치의 범위를 확장할 수 있으며, 다른 디스크 장치 포함 가능
    - 디렉터리 내의 정보 중 일부는 사용자 또는 어플리케이션이 이용 가능하나, 대부분 시스템 루틴에 의해 사용자에게 간접적으로 제공
    - 디렉터리 내 각 파일의 정보는 운영체제마다 다르다.
      - 파일명 : 기호로 된 각 파일의 이름은사람이 읽을 수 있어야 하며, 특정 디렉터리에서는 유일한 이름어이야한다.
      - 파일 형태 : 다른 유형들을 제공하는 시스템들을 위해 필요
      - 위치 : 파일이 존재하는 장치와 위치에 대한 포인터(경로명)
      - 크기 : 바이트, 워드 혹은 블록들로 나타내며 파일의 현재 상태 크기와 최대 허용 가능한 크기를 포함
      - 현재 위치 : 파일에서 현재의 판독이나 기록이 행해지는 위치의 포인터
      - 보호 : 액세스 제어 정보는 사용자에 따라 판독, 기록, 실행 등을 할 수 있는지의 여부를 제어
      - 사용 수 : 현재 개방된 파일을 사용하는 프레임 수
      - 시간, 날짜, 처리 식별 : 생성 시간, 수정 시간, 마지막 액세스 시간 등을 위해 유지, 보호와 사용 감시를 위해 이용
  - 디렉터리 구현
    - 디렉터리 공간 할당 및 관리 방법은 파일 시스템의 효율성과 신뢰성에 영향을 미친다.
    - 대부분의 디렉터리는 파일명, 파일 인덱스의 내용(리스트)을 포함하는 파일
    - 리스트 디렉터리 구현 방법은 아래와 같이 구분한다.
      - 선형 리스트
        - 디렉터리에 파일 이름, 포인터의 선형적 리스트를 구성, 파일의 생성 및 삭제 실행
        - 파일을 찾기 위해 선형 탐색 때문에 오버헤드 증가로 시스템 성능이 저하
      - 해시 테이블
        - 파일 이름 제시하면 해시로부터 값(포인터)를 얻어서 리스트를 직접 액세스
        - 디렉터리 탐색 시간을 줄이고 성능을 개선시켜 자주 이용
        - 