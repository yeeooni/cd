# 단일 프로세서 스케줄링 (2)

**스케줄링 알고리즘**
_대부분의 알고리즘은 대화식 사용자 환경과 빠른 응답시간을 구현하는데 집중되었다._
- 프로세스 스케줄러는 프로세스 스케줄링 알고리즘에 따라 프로세서를 할당, 작업을 완료한다.
- 여기서는 단일 프로세서로 구성된 시스템의 스케줄링 알고리즘을 살펴본다.

**선입 선처리 스케줄링(FCFS, First-Come-First-Served)**
_프로세서를 요구 순서대로 할당_
- 비선점 기법으로 프로세서 스케줄링 알고리즘 중 가장 간단하다.
- 선입선출(FIFO, First-In-First-Out) 큐로 구현한다.
- 일괄처리시스템에서는 효율적이나, 대화식시스템에서는 사용자의 빠른 응답 요구에 적합하지 않다.
- 새로운 작업이 시스템에 들어오면 프로세서의 PCB는 준비 큐의 마지막에 연결한다.
- 차례가 되면 준비 큐의 앞부분에 있는 프로세스는 프로세서를 할당 받고 준비 큐에서 삭제된다.
- 성능이 좋지 않는 경우가 많으며 평균 대기시간이 긴 경우도 있다.

**작업의 평균 변환 시간 계산**
- 프로세서 버스트 시간을 알고 있는 다음 세가지 작업의 평균 변환 시간을 계산한다.
- 작업이 P1, P2, P3의 순서로 들어왔다면, 다음과 같은 간트 도표 (GANTT CHEAR)로 나타낸다.
- 반환시간은 P1 24, P2 27, P3 30 평균 반환시간 27(=(24 + 27 + 30) / 3)
- 대기시간은 P1 0, P2 24, P3 27 평균 대기시간 17(=(0 + 24 + 27) / 3 )
- 작업이 P2, P3, P1의 순서로 들어온 경우 간트 도표는 다음과 같다.
- 평균 반환시간은 13(=(3 + 6 + 30) / 3), 평균 대기시간은 3(=(0 + 3 + 6) / 3)으로 단축된다.
- 프로세스의 실행시간에 따라 평균 반환시간과 평균 대기시간은 큰 폭으로 변화한다.

**동적 상황에서의 성능**
- 프로세서 중심 작업 1개와 입출력 중심 작업 3개가 있다고 가정한다.
- 프로세서 중심 프로세스가 프로세서를 할당받아 실행되는동안, 입출력프로세스들은 입출력을 끝내고 준비 큐로 이동하여 프로세서를 기다린다. 이때 입출력 장치들은 쉰다.
- 프로세서 중심 프로세서는 프로세서 작업을 끝내고 다시 입출력 큐로 이동한다. 이때 프로세서는 쉰다.
- 프로세서 중심 프로세서는 다시 준비 큐로 이동하여 프로세서를 할당 받고 다시 모든 입출력 중심의 프로세스들은 프로세서 중심 프로세스가 처리될 때까지 준비 큐에서 대기(반복처리)한다.
- 호위효과(Convoy Effect)
  - 하나의 프로세서 중심 프로세스가 프로세서를 떠나기를 기다리는 현상
  - 결과적으로 프로세서 중심 작업과 입출력 중심 작업의 불균형 상태를 의미한다.
- 선입 선처리 스케줄링 알고리즘은 정기적으로 프로세서를 공유하는 시분할 시스템에서 사용하기 힘들다.

**최소 작업 우선 스케줄링(SJE, Shortest Job First)**
- 프로세서 버스트 시간이 가장 짧은 작업에 프로세서를 할당
  - 이때 두 프로세스가 다음 순서로 동일한 프로세서 버스트를 가진다면 선입 선처리 스케줄링을 적용
  - 다음과 같은 작업들이 준비상태 큐에 있을 때, 최소 작업 우선 스케줄링을 사용하면 간트 도표가 이루어지며, 평균 반환시간은 (=(3 + 9 + 16 + 24) / 4)
  - 선입 선처리 스케줄링 사용 시 간트 도표
  - 평균 반환 시간 14 (=( 6 + 9 + 17 + 24 / 4)이며, 평균 대기시간 8(=(0 + 6 + 9 + 17 ) / 4)
  - 최소 작업 우선 알고리즘은 주어진 작업 집합에 대해 평균 대기시간이 최소이므로 최적 알고리즘
    - 실행시간이 짧은 작업(Short)을 실행시간이 긴 작업(Long) 앞에 놓는다.
    - 긴 작업의 대기시간은 증가하였으나, 짧은 작업의 대기시간이 줄어 평균 대기시간 감소
    - 프로세스 실행시간이 각각 5, 11, 7, 3 인 경우

**일괄처리시스템에서 장기 스케줄링**
- 작업의 제한 시간이 짧은 경우 빠른 반환을 요구, 사용자는 시간 한계를 정확히 예상해야한다.
- 시간 한계가 너무 짧을 경우 실행시간이 제한시간을 초과, 다시 작업을 입력해야한다.

_최소 작업 우선 스케줄링은 작업 스케줄링에서 많이 사용된다._
- 단기 스케줄링에서는 다음 프로세스의 프로세서 버스트 시간을 예상할 수 없으므로 하드웨어 구성이 어렵다.
- 이를 해결하기 위해 최소 작업 우선 스케줄링 근사치 사용

_비선점 스케줄링 알고리즘은 시분할 시스템에서 사용하기 힘들다._
- 최소 작업 우선 스케줄링은 선점 또는 비선점이 가능
- 시분할 시스템에서는 각 사용자들이 일정한 간격으로 프로세서 사용을 원한다.

**우선순위 스케줄링**
- 준비 큐에 도착한 프로세스와 현재 실행 중인 프로세스의 우선 순위 비교
  - 프로세스들의 우선순위를 비교하여 최고 우선순위를 가진 프로세스에 프로세서를 할당
  - 우선순위가 같은 프로세스들은 선입 선처리 순으로 스케줄 된다.

**최소 작업 우선 알고리즘은 우선 순위 알고리즘에 속한다.**
- 우선순위는 예측된 다음 프로세서 버스트의 역
- 프로세서 버스트가 클수록 우선순위가 낮으며, 그 반대도 성립한다.

**내부적 또는 외부적으로 우선순위 정의가능**
- 우선순위는 정해진 범위의 수 0 ~ 7, 0 ~ 4,096를 사용 : 0 이 최상위거나 최하위라고 정해지지 않는다.
- 내부적으로 정의된 우선순위
  - 프로세스의 우선순위 연산을 위해 제한시간, 기억장소 요구량, 사용 파일 수, 평균 프로세서 버스터에 대한 평균 입출력 버스트의 비율 등이 사용된다.
- 외부적인 우선순위
  - 프로세스의 중요성, 사용료를 많이 낸 사용자, 작업을 지원하는 부서, 정책적인 요인 등 운영체제 외적인 요소에 의해 결정된다.
- 선점, 비선저밍 가능
  - 새로 도착한 프로세스의 우선순위가 현재 실행되는 프로세스의 우선순위보다 높으면 프로세서를 선점
- 비선점 우선순위 스케줄링 알고리즘
  - 단순히 준비 큐의 머리 부분에 새로운 프로세스를 넣는다.
- 프로세스들이 같은 시간에 도착했다 가정
- 우선순위 스케줄링을 이용하여 스케줄링 한 결과를 아래의 간트도표와 같으며, 평균 대기 시간은 8.2이다.

**순환할당(Round-Robin) 스케줄링**
- 시분할 시스템을 위해 특별히 설계된다.
  - 규정 시간량(Time Quantum), 시간 할당량(Time Slice) 하는 작은 단위 시간 정의
  - 시간 할당량은 일반적으로 10 * 10 밀리 초에서 100 * 10 밀리 초 범위로 한다.
  - 준비 큐는 순환 큐로 설계, 프로세서 스케줄러가 준비 큐를 돌아가면서 한 번에 한 프로세스에 정의된 규정 시간량 만큼 프로세서를 제공
  - 준비 큐는 FIFO 큐 
  - 프로세서 스케줄러는 준비 큐의 앞부분에 있는 프로세스에 프로세서를 할당 (디스패치)
  - 규정 시간량이 지나면 인터럽트가 발생되며, 다음 두 가지 경우에 발생한다.
    - 규정 시간 내에 일을 끝내는 경우 : 프로세스는 자유로워지며 준비 큐에 있는 다음 프로세스를 진행
    - 현재 실행하고 있는 프로세스가 규정 시간량보다 긴 경우 : 운영체제에 의해 인터럽트 되며 중단된 프로세스의 레지스터들은 프로세스의 PCB에 저장, 프로세스는 준비 큐의 마지막 위치에 입력된다.

**스케줄러는 준비 큐에서 아래의 작업을 가져와 실행**
- 이전의 최소작업 우선 알고리즘의 작업을 적용한 예
- 규정 시간량을 4로 한 경우 순환 할당 스케줄링의 간트도표는 아래와 같다.
- P1는 처음 4만큼의 시간을 실행한 후 아직 4가 남아있지만 P2가 프로세서를 선점, 실행된다.
- P2는 시간을 4만큼만 원하므로 4시간 후 종료되며 P3 들어온다.
- P3는 4시간을 실행한 후 P4에 프로세서를 넘겨준다.
- 이후 앞서 종료되지 않은 P1이 실행된다.

**프로세스 반환시간은 작업 완료 시간에서 도착시간을 뺀 값**
- 평균 반환시간은 18.25(=(20 + 7 + 24 + 22) / 4)
- 평균 대기시간은 11.75(=(12 + 3 + 15 + 17) / 4)

**순환 할당 알고리즘은 선점 알고리즘**
- 프로세스가 규정 시간량보다 많은 실행시간 요청 시 스케줄러가 프로세스를 중단, 다음 프로세스를 대치

_순환 알당 알고리즘의 성능은 규정 시간량의 크기에 영향을 받는다._
- 준비 큐에 프로세스가 N개 있고 규정 시간량이 Q이면, 각 프로세스는 최대로 Q시간 단위로 프로세서 시간의 1/N을 얻는다.
- 각 프로세스는 자신의 다음 규정 시간량이 할당될 때까지 '(n-1) * q' 시간 이상을 대기하지 않는다.

**대화식 프로세스는 규정 시간량보다 짧은 시간을 요구**
- 실행을 시작할 때, 입출력 요청을 할 정도만 프로세서를 잠시 사용한 후 보류되고, 다음 프로세스에 프로세서를 양보
- 규정 시간량이 입출력까지의 계산시간보다 커야 입출력활용도를 극대화하고 대화식 프로세스에 빠르게 반응 가능
- 규정 시간이 아주 클 경우
  - 작업을 완료할 충분한 시간을 얻고 순환 할당 방식이 선입 선처리 방식으로 변한다.
  - 작업시간이 긴 프로세스들 때문에 작업시간이 짧은 프로세스들이 대기, 평균 대기시간이 길어진다.
- 규정 시간이 매우 작은 경우
  - 순환 할당률 프로세서 공유
  - 이론적으로 마치 n개의 프로세스가 실제 프로세서 속도의 1/n 의 속도로 실행되는 것처럼 보인다.

**프로세서 공유 방식**
- CDC(Control Data Corporation)에서 하드웨어 한 세트와 레지스터 10세트로 주변장치 프로세서 10개를 구현하는데 사용된다.
- 빠른 프로세스 하나가 아닌 느린 프로세서 10개를 이용하여 처리하는 것과 같다.
- 실제로 프로세서가 메모리보다 빠르고 각 명령어가 메모리 참조 시 프로세서들을 단일 프로세서보다 그리 늦지 않는다.

**최적의 규정 시간량 설정**
- 규정 시간량의 크기는 시스템 특성 및 오버헤드, 프로세스에 따라 다르다.

_문제점_
- 프로세서 중심 프로세스에서 대화식 프로세스를 지원, 선점을 통해 대화식 프로세스가 도착할 때 적절한 시간에 반응을 보여주도록 보장하는 것이 중요
- 소프트웨어 측면에서 문맥교환의 문제
  - 문맥교환 때문에 발생하는 오버헤드가 커지면, 시스템 성능 감소와 의미 있는 일의 수행보다 대부분의 시간을 문맥 전환에 사용
- 문맥교환 시간이 미치는 영향 예)
  - 시간 10을 소비하는 작업 수행 시, 규정 시간량이 12일 경우, 작업은 규정 시간 내에 끝난다.
  - 규정 시간량이 6일 경우, 작업은 규정 시간량 2번 요구, 1번의 문맥교환을 요청

**반환시간도 규정 시간량의 크기에 영향 받는다.**
- 규정 시간량에 따른 반환 시간의 변환
  - 한 프로세스 집합의 평균 반환시간은 규정 시간량의 크기가 증가하더라도 반드시 개선되지 않는다.
  - 대부분의 프로세스들이 단일 규정 시간량 안에 작업을 끝마치며 평균 반환시간은 개선된다.
- 시간 규정량에 따른 프로세스의 반환 시간
  - 실행 시간이 10인 3개의 프로세스들이 있고 규정 시간량이 1시간일 경우, 평균 반환시간은 29 (= ( 28 + 29 + 30 ) / 3 ) 
  - 규정 시간량이 10인 경우 평균 반환시간은 20 ( = (10 + 20 + 30 ) / 3 )으로 떨어진다.
  - 규정 시간이 작을 경우 문맥교환이 많이 일어나므로 평균 반환시간이 좋지 않다.

**다단계 큐(Multi - Level Quere) 스케줄링**
- 각 작업들은 서로 다른 묶음으로 분류할 수 있을 때 사용
  - 작업을 전면작업(대화형, ForeGround Task), 후면작업(일괄처리형, BackGround Task)으로 분류 시, 두 유형의 요구 반응 시간이 다르므로 서로 다르게 스케줄링해야 한다.
  - 전면작업은 후면작업에 비해 높은 우선 순위를 가진다.
- 준비상태 큐를 종류별로 여러 단계로 분할해둔다.

**각 작업들은 서로 다른 묶음으로 분류할 수 있을 때 사용**
- 작업을 기억장치의 크기나 프로세스의 형태에 따라 어느 한 큐에 지정
- 각 큐는 자신만의 독자적인 스케줄링 알고리즘을 갖는다.
- 큐 사이에도 스케줄링이 있어야하며, 이는 고정된 우선순위의 선점식 스케줄링이다.
- 큐들 사이에 시간을 나누어 사용 가능
  - 각 큐는 프로세서 시간의 일정량을 받아서 큐에 있는 프로세스들은 스케줄링 할 수 있다.
- 큐 5개 가진 다단계 큐 스케줄링 알고리즘 
  - 각 큐는 순서대로 절대적인 우선순위를 가진다.
  - 앞의 세 가지 큐가 비어있어야 네 번째 일괄 처리 큐에 있는 프로세스가 실행된다.

**다단계 피드백 큐 스케줄링**
- 작업이 시스템에 들어가면 한 큐에서만 고정
  - 전면작업과 후면작업에 대한 독립된 큐가 있어도 작업은 한 큐에서 다른 큐로 옮겨지지 않는다.
  - 작업은 그 성격상 전면작업과 후면작업의 성질을 바꿀 수 있는 것이 아니기 때문
  - 스케줄링 부담이 적으나 융통성이 떨어진다.
  - 프로세서 버스트의 특성에 다라 분리하여 구분하며, 작업이 큐 사이를 이동 가능
  - 다단계 피드백 구조
    - 어떤 작업이 요구하는 프로세서 시간이 너무 길면 작업을 낮은 단계 큐를 옮긴다.
    - 입출력 중심 작업과 전면작업(대화식 작업)을 높은 우선 순위 큐에 놓고 프로세서 중심 프로세스는 낮은 우선순위 큐에 놓는다.

**문제점 및 해결방법**
- 기아상태에 빠질 가능성이 있다.
  - 프로세서 버스트 시간이 작은 프로세스에 우선권을 주어 일찍 종료시키고 다음 입출력 버스트를 실행하며, 이는 입출력 위주의 프로세스에 우선권을 주는 기법
  - 높은 우선순위의 큐가 완전히 비어야 낮은 우선순위의 준비 큐에 있는 작업이 실행 가능
  - 낮은 우선순위의 큐에 입력된 작업이 기아상태에 빠질 수 있다.
- 에이지 방법을 활용
  - 특정 큐에서 오래 기다린 프로세스를 우선순위가 높은 큐로 이동, 프로세서 점유 시간이 긴 작업을 우선 순위가 낮은 큐로 이동시켜 기아상태 예방

**프로세서를 할당 받을 시 규정 시간을 더 얻는다.**
- 프로세스들이 더 낮은 수준의 큐로 이동 시, 스케줄러는 해당 프로세스들의 규정 시간량을 증가시켜 프로세스가 더 오래 작업할 수 있도록 한다.
- 다단계 피드백 큐
  - 큐 4개가 있는 다단계 피드백 큐 스케줄렁
  - 각 큐는 0 ~ 3까지의 번호를 가진다.

**다단계 피드백 큐 스케줄링 알고리즘의 우선순위**
- 프로세서 버스트가 2 이하인 모든 프로세스에 최고의 우선순위를 부여한다.
  - 최고의 우선순위를 부여받은 프로세스는 프로세서를 할당 받아 프로세서 버스트를 끝내고 다음 입출력 버스트로 이동
- 4 이상 16 이하의 규정 시간량이 필요한 프로세스들은 규정 시간이 더 짧은 프로세스들보다는 낮은 우선순위를 받으나 역시 서비스를 빨리 받을 수 있다.
- 규정시간이 긴 프로세스들은 자동적으로 큐 3 으로 가며, 큐 1, 큐 2의 프로세스 주기에 여유가 생기면 선입 선처리 방식으로 처리된다.

**정의**
- 큐 의 수
- 작업을 좀 더 높은 우선순위의 큐로 격상시키는 시기를 결정하는 방법
- 작업을 좀 더 낮은 우선순위의 큐로 격하시키는 시기를 결정하는 방법
- 프로세스들이 어느 큐에 들어갈 것인가를 결정하는 방법
- 프로세스가 서비스를 받는 시기를 결정하는 방법
- 다단계 피드백 큐 스케줄러의 정의에 의해 프로세서 스케줄링 알고리즘 중 가장 일반적인 기법, 이 정의들은 특정 시스템에 맞게 적용 가능
- 최상의 스케줄러를 정의하기 위한 요소들의 평가치를 찾기 위한 어떤 방법이 요구된다는 단점을 가지며, 이로 인해 가장 복잡한 알고리즘이라 할 수 있다.

**순환할당 알고리즘과의 비교**
- 동일한 시간(t=0) 프로세서 중심의 프로세스 시스템이 3개 있다고 가정
- 프로세서 버스트 길이는 각 p1(30), p2(20), p3(10)
- 시스템은 각 큐 1(1), 큐 2(2), 큐 3(4)의 규정 시간량을 할당하며, 순환할당 알고리즘의 규정 시간량은 1
- 반환시간 및 대기시간을 계산하기 위한 다단계 피드백 큐의 간트도표

**순환할당 알고리즘과의 비교**
- 순환할당(RR) 및 다단계 피드백 큐 (MLFQ) 스케줄링 알고리즘의 반환시간 및 대기시간은 아래와 같다.
- 프로세스를 변경하여 앞의 예제와 비교
- 시스템은 각 큐 1(2), 큐2(4)의 규정 시간량을 할당
- 프로세스 (P3)는 2 단위 프로세서 버스트 실행 후에 1 단위 입출력 버스트를 실행
- 입출력 버스트 실행 후 P3은 큐 1로 돌아가 입출력 장치에 보류하면서 남은 시간만큼 다시 수행
- 반환시간 및 대기시간을 계산하기 위한 다단계 피드백 큐의 간트도표

**HRN(Highest Respones-Rate Next) 스케줄링**
- 한슨 (Brinch Hansen) 개발
  - 최소 작업 우선(SJF) 기법의 약점이었던 긴 작업과 짧은 작업 간의 지나친 불평등을 어느 정도 보완한 기법
  - 비선점 스케줄링 기법으로 각 작업의 우선순위는 작업이 서비스 받을 시간 뿐만 아니라 서비스를 기다린 시간 등 두 가지의 함수로 나타낸다.
  - 한 작업이 프로세서를 차지하면 작업이 종료될 때까지 실행된다.
  - HRN 기법의 가변적 우선순위는 다음 식에 따라 계산된다.
  - 서비스를 받을 시간이 분모에 있으므로 서비스를 받는 시간이 짧은 작업이 우선순위가 높다.
  - 대기한 시간이 분자에 있으므로 서비스를 받을 시간이 긴 작업도 개시한 시간이 큰 경우에 우선순위가 높아진다.
  - 따라서 시스템의 응답시간은 다음과 같이 나타낼 수 있다.
    - 시스템의 응답 시간 : 대기한 시간 / 서비스를 받을 시간

**다중 처리기 스케줄링**
- 강결합 다중 처리기 시스템을 중심으로 다중 프로세스의 구조를 살펴본다.
- 각 프로세서들은 독자적인 큐와 독자적인 알고리즘을 가지므로 프로세서가 다르면 선택의 여지는 상대적으로 제한된다.
- 작업은 프로세스의 구저에 따라 특정하게 지정, 특정 프로세서의 의해 실행되어야한다.
- 같은 종류의 프로세서가 한 시스템에 여러개 있다면 부하 공유가 발생한다.
- 이를 방지하기 위해 각 프로세서에 서로 독립된 큐를 제공
  - 프로세서의 할당이 모든 프로세스에 한 번만 이루어지므로 스케줄링 오버헤드가 적다.
  - 어떤 프로세서는 큐가 비어 아무 일도 하지 않을 수도, 다른 프로세스는 처리할 작업이 준비 큐에 가득 차 매우 바쁠 수 있다는 단점이 있다.
- 공동의 준비 큐를 통해 모든 작업이 이용 가능한 프로세서 큐로 가도록 스케줄한다.
  - 프로세스가 메모리에 적재되는 동안 다른 프로세서에서 작업을 실행 가능
- 강결합된 공유 메모리 구조에서 모든 프로세서는 모든 프로세스에 대한 문맥정보를 이용할 수 있다.
  - 프로세스의 스케줄링 비용은 프로세스가 스케줄되는 프로세서에 독립적

**두 가지 스케줄링 방법 사용**
- 프로세서 자신이 스스로 스케줄링 하는 것
  - 각 프로세서 공통의 준비 상태 큐에서 실행시킬 프로세스 하나를 선택
  - 두 프로세서가 같은 프로세스를 선택하지 않아야 하며, 프로세스가 큐에서 누락되지 않도록 해야한다.
  - 단일 프로세서 스케줄링(우선순위, 순환할당) 기법의 활용이 가능하나, 스케줄링이 복잡하여 오버헤드를 증가시킬 수 있다.
- 한 프로세서를 다른 모든 프로세서의 스케줄러로 지정, 주/종 구조 가진다.
  - 비대칭 다중 프로세싱
  - 운영체제의 핵심 커널 기능들을 특정 프로세서에서 수행, 다른 프로세서들은 사용자 프로그램들만 수행한다.
  - 주 프로세서는 프로세스들을 스케줄링하여 프로세스를 활성화 시킨다.
  - 종 프로세스가 입출력 호출 등의 서비스가 필요할 때 주 프로세서에 요청하여 서비스의 처리가 완료되길 기다린다.
  - 단일 프로세서 다중 프로그래밍 기법과 유사하며 자원 출동 문제를 해결할 수 있다.
  - 주 프로세서의 오류는 시스템 전체를 정지시키며, 주 프로세서의 과중한 오버헤드는 성능의 병목 지점이 될 수 있다는 단점이 존재

**스레드 스케줄링**
- 스레드 실행의 개념
- 어플리케이션과 같은 주소 공간에서 동시에 실행하고 협동하는 스레드들로 구현 가능 
- 스레드 교환은 프로세스 교환보다 오버헤드가 적어 성능을 향상시킬 수 있다.

**부하 공유(Load Sharing)**
- 프로세서를 특정 프로세스 하나에 할당하지 않고 전역 큐에서 프로세서를 유지
- 쉬고 있는 프로세스는 전역 큐에서 스레드 하나를 선택
- 단일 프로세서 환경에서 사용한 기법을 그대로 채택한 가장 간단한 다중 프로세서 기법
- 부하 공유의 장점
  - 부하는 프로세서들에 균등하게 분산되며 실행 대기 중인 작업에는 분산되지 않는다.
  - 스레드 제어를 위한 중앙 제어 스케줄러 없이 사용 시, 현재 작업을 진행한 프로세서에서 다음 작업을 선정
  - 전역 (공유) 큐는 선입 선처리 (FOFS), 우선순위 기법을 이용하여 구성 가능
- 부하 공유의 단점
  - 중앙 큐는 상호배제방식으로 접근되는 메모리 영역을 많은 프로세서가 동시에 작업을 찾을 시 병목지점이 될 수 있다.
  - 선정된 스레드들은 동일한 프로세서 상에서 실행을 재개하기 어렵다.
  - 프로그램의 스레드들 사이에 밀접한 협조가 요구된다면 관련된 프로세스 교환은 성능을 저하시킬 수 있다.
- 현재 다중 프로세서 상에서 가장 일반적으로 사용되고 있다.

**갱 스케줄링**
- 관련된 스레드의 집합이 일대일 대응 원칙에 따라 프로세서 집합에서 동시에 실행될 수 있도록 스케줄링하는 기법
- 단일 프로세스에 속한 스레드들이 동시에 스케줄링된다.
- 동기화 보류 및 프로세스 문맥교환의 횟수를 최소화하여 성능을 향상시킬 수 있다.
- 스케줄링 오버헤드를 감소시킬 수 있다.

**전용 프로세서 할당**
- 스레드들은 실행 전담 프로세서에서 할당하여 정의된 스케줄링 제공
- 각 프로그램을 실행되는 동안 프로그램 내의 스레드 개수와 동일한 수의 프로세스를 할당받으므로 프로세스 낭비 가능
- 프로세스의 합리적인 이용의 자원이 필요
  - 활성화된 스레드의 개수를 시스템상의 프로세서와 동일한 개수로 제한하여 효율성을 높인다.

**동적 스케줄링**
- 프로세스 내의 스레드 수를 동적으로 변경하여 운영체제가 시스템 이용률을 높일 수 있도록 부하 조절을 허용한 기법

_알고리즘 기법_
- 알고리즘 선택 기준
- 알고리즘 선택 시 사용 기준 정의가 모호해 선택이 어렵다.
  - 일반적으로 프로세스 이용률, 응답시간, 처리율을 선택 기준으로 이용하나, 이들의 기준을 정의하는 것이 어렵다.
  - 이용하기 위해선 측정한 내용의 상대적인 중요성 정의 필요
  - 아래의 예가 기준이 되며, 선택 기준이 정의 되면 다양한 알고리즘을 평가 가능
    - 최대 응답 시간이 1 초라는 제약 조건에서 프로세서 이용률
    - 평균 반환시간이 전체 실행 시간에 선형적으로 비례하는 처리율

**분석적(해석적) 평가**
- 작업 부하(WorkLoad)를 줄이기 위해 알고리즘의 성능을 평가하는 공식 값을 생성하기 위한 알고리즘, 시스템 작업 부하를 이용
  - 결정성 모형화 : 분석적 평가의 한 형태로 이 방식은 사전에 정의된 특정한 작업에 대하여 각 알고리즘의 성능 평가 
