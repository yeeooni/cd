# 입출력 시스템, 디스크 관리(2)

- 디스크 스케줄링

  - 입출력 장치(디스크 드라이버)는 요청(Request)을 위한 큐를 가진다.

  - 프로세서는 입출력이 필요할 때마다 운영체제에 시스템 호출을 보낸다.

  - 요청은 다음과 같은 정보를 포함한다.

    - 입력 동작인지, 출력 동작인지에 대한 정보
    - 디스크 주소(구동기, 실린더, 표면, 블록)
    - 메모리 주소
    - 전송할 정보의 총량(바이트 또는 단어의 수)

  - 디스크 드라이버, 제어기를 사용할 수 있다면 요청을 즉시 처리 가능

  - 다른 프로세스가 둘 중 하나라도 사용하고 있다면 요청은 디스크 대기 큐에 저장

  - 디스크 대기 큐에서 시스템의 스케줄링은 몇 가지 기준으로 평가할 수 있다.

    - 처리량 단위 : 시간당 처리한 서비스 요청의 수
    - 탐색 시간 : 디스크 헤드(암) 이동 시간
    - 평균 반응 시간 : 요청 후 서비스 될 때까지의 대기 시간
    - 반응(응답) 시간 변화 : 반응 시간에 대한 예측 정도(적절한 시간 안에 서비스 하여 요청이 무기한 연기되지 않도록 방지)

    _스케줄링 정책은 처리량을 최대화하고 평균 반응 시간과 탐색 시간을 최소화해야한다. 처리량 및 평균 반응 시간 최적화로 시스템 성능 향상은 가능 하나 개별 요청에 지연 발생 가능_

- 선입 선처리 스케줄링(FCFS, First-Come-First-Serverd)

  - 디스크 스케줄링의 가장 간단한 형태
  - 요청이 도착한 순서에 따라 처리
  - 프로그램이 하기 쉽고 어떤 요청도 무기한 연기되는 경우가 없으며 본질적으로 공평성이 유지된다.
  - FCFS 스케줄링의 예)
    - 처음 요청이 트랙 98, 마지막은 트랙 67로 되는 선형 요청 디스크 큐
  - 문제점
    - 디스크 요청이 흩어져 있는 경우 실행 시간 오버헤드는 적으나 탐색 시간이 오래 걸려 처리량이 감소된다.

- 최소 탐색 시간 우선 스케줄링(SSTF, Shortest Seek Time First)

- 최소 위치 결정 시간 우선(SPTF, Shortest Positioning Time First)

  - 디스크 요청을 처리하기 위해서 헤드가 먼 곳 까지 이동하기 전에 현재 헤드 위치에 가까운 모든 요구를 먼저 처리하는 기법
  - 디스크 처리 시간을 줄일 수 있으나, 디스크 요구의 기아 상태 발생 가능

  _배치 처리 시스템의 경우 반응 시간의 변화가 커도 미치는 영향이 작아 SSTF의 적용이 가능하나, 대화식 처리 시스템의 경우 SSTF의 불확실한 예측 가능 시간 때문에 적용하기 부적당하다._

- 스캔 스케줄링

  - 요청 큐의 동적 특성 반영
  - 입출력 헤드가 디스크의 한 끝에서 다른 끝으로 이동
  - 한쪽 끝에 도달했을 때는 역 방향으로 이동하면서 요청한 트랙을 처리
    - 헤드는 디스크의 한 끝과 다른 끝 사이를 계속해서 왕복
    - 새로운 디스크 요청이 헤드의 바로 앞 요청의 큐에 도착하면 즉시 처리되나, 헤드 뒤에 있는 경우 헤드가 디스크의 끝까지 이동하고 돌아올 때까지 기다려야한다.
  - 엘레베이터와 동작이 유사하여 엘리베이터 알고리즘이라 부르며, 눈 치우기와 비슷하다.
    - 각 트랙에 대한 요청이 균등하다고 가정하면, 눈이 쌓이는 현상과 비슷하게 헤드가 한쪽 끝에 이르러 방향을 바꾸어야 할 시점에서 요청 밀도가 높은 쪽은 최초의 시작 부분이며, 나중에 처리된 헤드 바로 뒷 부분은 비교적 밀도가 낮다.
    - 밀도가 높은 쪽의  요청은 오랜 시간 기다리게 된다.

- 순환 스캔 스케줄링(C-SCAN, Circular SCAN Scheduling)

  - 스캔 알고리즘을 변형, 대기 시간을 균등하게
  - 스캔 스케줄링 처럼 헤드는 한 쪽 방향으로 이동하면서 요청을 처리하지만, 한쪽 끝에 다다르면 반대 방향으로 헤드가 이동하지 않고 다시 처음부터 요청을 처리
  - 처음과 마지막 트랙을 서로 인접시킨 것과 같은 원형처럼 디스크를 처리, 처리량을 향상
  - 바깥 트랙과 안쪽 트랙에 대한 차별이 없어 반응 시간의 변화를 줄인다.
  - 동일한 실린더(트랙)에 대한 요청이 연속적으로 발생되면 처리가 무기한 연기될 수 있다.

- 룩 (LOOK) 스케줄링

  - 스캔, 순환 스캔 방법은 원리와 달리 구현
  - 헤드는 요청에 따라 각 방향으로 이동, 현재 방향에 더 이상의 요청이 없을 때 이동 방향을 바꾼다.
  - 스캔과 순환 스캔의 이런 형태를 룩(look), or 순환 룩(C-LOOK)라 부른다.
    - LOOK : 진행 방향으로 움직이기 전에 먼저 요청이 있는지 검사함을 의미한다.

- 회전 최적화

  - 디스크 스케줄링 알고리즘은 대기 시간과 총 처리 시간을 줄이기 위해 디스크 헤드 이동을 최소화 하는데 목적을 가진다.
  - 초기 시스템과 달리 현재의 디스크 시스템은 탐색 시간과 평균 지연 시간이 비슷하여 회전 최적화로도 성능 개선이 가능하다.
  - 일괄처리 프로세서들은 데이터의 트랙 전체를 액세스하므로 회전 최적화의 효과를 얻지 못한다.
  - 대화식 프로세스 같은 디스크의 실린더에 분산된 소량의 데이터만 요구하는 요청이 많을 경우, 회전 최적화로 성능 개선이 가능하다.

- 최소 지연 시간 우선 스케줄링(SLFT)

  - 모든 요청 중 회전 지연 시간이 가장 짧은 요청을 먼저 처리한다.
  - 디스크 헤드가 특정 실린더에 도달했을 때 해당 실린더의 트랙들에 대한 요청이 대기하고 있다면, 헤드는 더 이상 움직이지 않고 도착 순서와 관계없이 모든 요청을 우선 처리한다.
  - 트랙을 일정한 수의 블록으로 나눈 섹터를 토대로 요청들을 섹터 위치에 따라 큐에 넣고 가까운 섹터에 대한 요청을 먼저 처리한다.
  - 디스크 액세스 요청(디스크의 주소)는 트랙과 섹터로 구성
  - 고정 헤드에서는 탐색을 하지 않으므로 탐색 시간이 없다.
  - 회전 지연 시간만이 지연 시간이 되므로 드럼과 같이 고정 헤드를 사용하는 경우 효과적이다.

- 섹터 큐잉 (Sector Queueing) 알고리즘

  - 고정 헤드 디스크의 다음 섹터를 위한 경로 선택 시, 섹터 지원 시간의 간격은 트랙이 전환하는데 걸리는 시간
    - 최대 가동률은 '액세스 된 사용자 블록 수 / 통과된 디스크 블록 수 ' 이다.
  - 고정 헤드 장치에서도 사용되나 특별한 트랙마다 실린더 내에 처리 요청이 하나 이상일 때는 이동 헤드 장치에서도 사용할 수 있다.
  - 헤드가 특정한 실린더에 도착하면 헤드를 더 이상 움직이지 않고 실린더에 대한 모든 요청을 처리한다.
  - 같은 실린더 내에서 다중 요청의 정렬에 사용가능하다.
  - 운영체제가 하나 이상의 요청 중에서 헤드 밑에 위치한 첫 요청을 선택해야만 효과가 있다.
  - 가장 짧은 위치 결정시간, 즉 탐색 시간과 회전 지연 시간의 합이 가장 짧은 요청을 다음 서비스 대상으로 선택
  - 최소 탐색 시간 우선(SSTF)와 같이 처리량이 많고, 평균 반응 시간은 짧으나 가장 안쪽과 바깥쪽 실린더에 대한 요청이 무기한 연기될 가능성이 있다.

- 에선바흐 기법(Eschenbach Schema)

  - 탐색 시간과 회전 지연 시간을 최적화하기 위한 기법
  - 헤드는 순환 스캔 스케줄링과 같이 진행 하나 요청과 관계없이 트랙 한 바퀴 회전할 동안 요청을 처리하도록 요청을 재배열
  - 1 회전 동안 섹터 내의 많은 레코드들이 처리되어 회전 지연 시간을 줄인다.
  - 회전은 한 방향으로 진행되므로 두 개의 요청이 실린더의 같은 섹터에 있으면 한 개의 요청만 처리되어 순환 스캔 스케줄링 보다 성능이 감소된다.

- 디스크 스케줄링 알고리즘의 선택

  - 성능은 요청의 형태와 요청의 수에 좌우된다.
  - 큐가 하나 정도 밖에 요청하지 않는다면 모든 스케줄링 알고리즘의 효과과 거의 같다.
  - 이 경우 선입 선처리 스케줄링이 가장 적당하다.
  - 디스크 서비스의 요청은 파일 할당 방법에 많은 영향을 받는다.
  - 연속적으로 할당된 파일을 읽는 프로그램은 디스크 상의 인접된 범위 내에서 많은 요청이 발생, 헤드의 이동을 제한한다.
  - 링크 파일이나 색인 파일의 경우, 블록 들이 디스크에 흩어져 헤드의 이동거리는 같지만 디스크 상용 효율은 높다.
  - 디렉터리 위치에 따라 이동거리가 달라진다.
  - 모든 파일은 개방되어야 사용 가능하며, 파일 개방을 위해 디렉터리 구조를 조사해야 하므로 디렉터리가 자주 호출된다.
  - 디렉터리를 디스크의 양 끝에 두는 것보다 중간 부분에 두는 것이 디스크 헤드 이동을 줄일 수 있다.
  - 디스크는 시스템의 성능과 신뢰성 측면에서 병목현상의 주요 원인이 된다.
  - 컴퓨터 장치 중 가장 속도가 느리다.
  - 전반적인 시스템의 성능은 아직 디스크의 속도와 신뢰성에 좌우된다.

  

- RAID(Redundant Array of Inexpensive or Independent)

  - 운영체제로 다수의 물리적 디스크를 하나의 논리적 디스크 인식 기술

  - 다수의 장치로 컴퓨터 성능 향상을 위한 연구 결과

  - 디스크 장치를 독립적이며 병렬적으로 작동시키는 디스크 배열 기술

  - 초기 RAID

    - 프로세서와 디스크의 속도 차이를 극복하기 위해 여러 대의 디스크 장치를 이용하여 다수의 드라이브에 있는 데이터를 동시에 액세스할 수 있도록 데이터 분산 저장

  - 데이터의 중복에 대한 필요성을 효과적으로 해결하는데 도움

  - 계층

    - 여러 개의 하드 디스크를 하나의 논리적 가상 디스크로 구성, 대용량 저장 장치를 사용할 수 있는 기법
    - 데이터를 여러 개의 하드 디스크에 분할, 저장 하여 전송 속도를 향상 시키고 시스템 가동 중 생길 수 있는 디스크의 오류를 시스템 정지 없이 교체 가능
    - 총 6 계층으로 분류 되며,  서로 다른 용도로 사용된다.
    - 초기 제안자들이 6개로 구분했던 각 계층은 다양화
    - 구성과 기능면에서 다르게 변했으므로 사용자의 목적에 맞는 계층 구성이 필요하다.
    - 초기 6계층 외 여러 방식이 개발 되었으나 0, 1, 0 +1, 5를 제외한 나머지 방식들은 거의 사용되지 않는다.

  - RAID 0

    - 일련의 데이터를 하나의 논리적 디스크 배열에 일정한 크기로 나누어 분산 저장하는 기법
    - 데이터를 사용 가능한 디스크에 나누어 저장
    - 사용자와 시스템 데이터는 하나의 논리 디스크 상에 저장 되어 있는 것으로 인식
    - 디스크는 스트립으로 나누어 연속적인 배열 첨자(구성요소). 대용되도록 순환 할당
    - 스트라이프(Stripe) : 하나의 스트립들과 각 배열의 구성 요소가 대응 하는 논리적으로 연속적인 스트립들의 집합
    - n - 디스크 배열에서 첫 번째 n개의 논리 스트립들은 디스크 n개의 각 각 첫 번째 스트립으로 저장
    - 두 번째 n개의 스트립들은 각 디스크의 두 번째 스트립들로 분산 저장
    - 동일한 하드 디스크 여러 대를 병렬 방식으로 구성, 입출력 시간을 감소 시킬 수 있다.
    - RAID 0 계층은 스트라이프를 가지고 있으나 데이터를 중복해서 기록하지 않아 장애 발생에 대비한 여분의 저장 공간을 가지고 있지 않다.
    - 어느 한 드라이브에서 장애 발생 시 데이터는 손실
    - 안정성을 추구하는 RAID 시스템에 부합되지 않는다는 사실을 알 수 있다.
    - 데이터를 입출력 할 때, RAID 컨트롤러에서 여러 개의 하드 디스크로 나눠 쓰고 읽는다.
    - 중요하지 않은 데이터에 대한 빠른 데이터 입출력 성능이 요구되는 동영상 편집 등에 적합하지 않다.

  - RAID (미러링)

    - 데이터 스트라이핑을 사용하면서 배열 내의 모든 디스크가 동일한 데이터를 가지는 미러 디스크를 가진다.
    - 각 논리적 스트립은 두 개의 별도 디스크에 대응 되므로 미러링
    - 중복 저장된 데이터를 가진 적어도 두 개의 드라이브로 구성
    - 읽기 요구
      - 요구 데이터를 가지고 있는 두 개의 디스크 중 어떤 디스크에서도 서비스를 받을 수 있어 성능이 향상된다.
      - 데이터를 분할 저장 하지 않아 두 스트립이 갱신 되어야한다.
    - 쓰기 요구
      - 단일 디스크 드라이브의 경우와 동일하며, 병렬적으로 갱신한다.
    - 드라이브에 장애 발생 또는 데이터 손상 발생 시, 즉시 두 번째 디스크를 통해 액세스 가능
      - 전체 용량의 절반이 여분의 데이터 기록을 위해 사용되어9 지원하는 논리적 디스크 공간의 두 배가 필요하므로 비용이 증가한다.
    - 성능
      - 읽기 요구가 많은 경우 높은 입출력 달성 (RAID 0 보다 2 배 증가)
      - 쓰기 요구가 많은 경우 RAID 0 의 성능과 비슷
      - 시스템 드라이브 등의 중요 파일에 적합하다.

  - RAID 2 (허밍코드를 통한 중복)

    - RAID 2, RAID 3는 병렬 액세스 기법 사용

    - 모든 맴버 디스크는 모든 입출력 요구에 참여한다.

    - 디스크들 간에 데이터 스트라이핑을 사용하며, 오류 검출 능력이 없는 드라이브를 위해 허밍코드 기법을 사용한다.

    - 몇몇 디스크들은 오류 감지 및 수정을 위해 사용되는 오류 정정 코드(ECC, Error Coorrecting Code) 정보가 저장되어 있다.

    - 허밍 오류 정정 코드는 패리티 비트를 사용, 디스크로부터 전송된 데이터에 오류가 있는 확인 및 오류 정정

    - 실시간 오류 수정이 가능 하다.

      - 현재의 SCSI 드라이브들이 자체 오류 검출 능력을 가지므로 별로 쓰이지 않는다.
      - 디스크 오류 발생이 많은 경우 효과적이다.
      - 디스크의 신뢰성이 높으면 낭비가 크므로 구현 자체가 제외된 경우가 많다.

      _빠른 기록 속도와 함께 장애 복구 능력이 요구되는 경우에 사용, 드라이브 두 대만으로 구성할 수 있어 작은 시스템에 적합_

  - RAID 3 (비트 인터리브 된 패리티)

    - 데이터 분산 저장을 위해 스트라이프 사용
    - 오류 검출과 수정을 위해 별도의 드라이브 한 개를 패리티 드라이브로 사용
    - 내장된 오류 정정 코드 정보는 오류를 감지하는 데 사용하며, 데이터 복구는 다른 드라이브에 기록된 XOR를 개선하여 수행
    - 각각의 데이터 디스크에 데이터를 비트 단위로 스트라이핑 하여 기록
    - 디스크에 입출력할 때 데이터의 크기가 K바이트 일 경우, N개의 디스크에 나누어져 (K/N) 분산 저장되고, N + 1 디스크에는 패리티 비트가 저장된다.
    - 바이트 단위의 분산 저장을 경제적으로 수행하기 위해 하드웨어적인 자원이 필요하다.

  - RAID 5  (블록 인터리브  된 분산 패리티 블록)

    - RAID 4  유사하나, 별도의 패리티 드라이브 대신에 모든 드라이브에 패리티 정보를 나누어 저장한다.
    - 패리티를 담당하는 디스크의 명목현상을 일으키지 않는다.
    - 다중 프로세스 시스템에서와 같이 작고 잦은 데이터 기록이 있는 경우 빠르다.
    - 읽기 요청의 경우 각 드라이브에서 패리티 정보를 건너 뛰어야 하므로 RAID 4 보다 느리다.
    - 최소한 3대, 일반적으로 5대 이상의 드라이브가 필요
    - 데이터는 각 데이터 영역에 블록 단위로 스트라이핑하여 저장
    - 데이터 입출력 성능이 빠르면서도 안정성 또한 높아 파일 서버 등 입출력이 빈번한 업무에 적합
    - 현재 가장 널리 사용되는 RAID 방식

  - RAID Level 0 + 1

    - 스프라이핑 방식과 미러링 방식을 혼합한 형태로 각각의 장점을 살린 시스템

    - 미러링은 반드시 똑같은 수의 디스크를 필요로 하므로, 디스크 두 개를 사용하여 스트라이핑 하려면 최소 네 대의 디스크가 필요하다.

    - 쓰기 속도는 디스크 두 개로 스트라이핑 할 때와 같으며 디스크 네 개에서 나눠서 읽어 오기 때문에 읽기 속도가 빠르다/

    - 미러링으로 같은 디스크 복사본을 가지고 있어 디스크 오류 발생 시 복구가 가능하다.

    - 디스크가 다수 필요하므로 안정성과 빠른 속도가 모두 필요한 중대형 서버에 많이 사용한다.

      