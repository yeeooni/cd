# 프로세스, 스레드(2)

**프로세스에서 실행 제어만 분리한 실행 단위**
- 경량 프로세스(LWP)
  - 중량 프로세스 (HWP)는 스레드를 하나 가진 작업
- 프로세서를 사용하는 기본 단위이며, 명령어를 독립적으로 실행할 수 있는 하나으 ㅣ제어 흐름
- 작업 : 스레드의 그룹 환경
  - 같은 그룹의 스레드, 코드, 주소 공간, 운영체제의 자원(파일, 신호) 등 공유
- 작업에 스레드가 없으면 아무 일도 할 수 없으므로 반드시 스레드가 있어야 한다.


**프로세스는 스레드를 하나 이상 가지며, 각 스레드는 아래 내용을 포함**
- 스레드 실행 시 상태(실행, 준비)
- 실행 스택
- 지역 변수, 스레드의 특징 데이터를 저장하기 위한 스레드별 정적 저장소
- 프로세스의 다른 스레드가 공유하는 프로세스의 메모리와 자원에 대한 접근 등의 스레드 실행 환경 정보(문맥 정보)

**스레드의 장점**
- 프로세스에 포함된 스레드들은 공통의 목적 달성을 위해 병렬로 수행
  - 자원을 공유하여 한 프로세스에 동시 작업 가능
- 시스템 성능과 효율 향상
  - 하나의 프로세스가 서로 다른 프로세서에서 프로그램의 다른 부분을 동시에 실행 가능
  - 응용 프로그램 하나가 비슷한 작업들을 여러개 수행

**운영체제는 단일 프로세스에서 단일 스레드 실행과 다중 스레드 실행을 지원**
- 단일 스레드 프로세스 
  - 프로세스 하나에 스레드 하나가 실행되는 전통적인 방식으로 스레드의 개념이 불확실 
  - MS-DOS
- 다중 스레드 프로세스
  - 프로세스 하나에 여러 스레드를 실행하는 것을 지원
  - 윈도우 NT/XP, 솔라리스 등

**다중 스레드의 특징**
- 각 스레드를 별도의 프로세서에서 실행하는 측면 다중 프로세싱 (프로세서)와 같은 의미
- 동일 프로세스 내에 스레드는 메모리와 파일을 공유하므로, 프로세스 하나에 다수의 실행 단위로 구분된 자원을 공유
- 자원 생성과 관리의 중복성을 최소화하여 실행 능력 향상
- 각 스레드는 커널 개입 없이 서로 통신이 가능하여 독립적으로 실행
- 서버에서 많은 요청을 효과적으로 처리할 수 있는 환경
- 프로세서를 새로 생성하는 것보다 기존 프로세스에서 스레드를 생성하는 것이 빠르고, 같은 프로세스 내 스레드 간 교환이나 스레드 종료 역시 빠르다.
- 프로세스의 상대적인 무게를 줄여 효율을 극대화하는 것이 목표
- 프로그램 변경없이 프로세서의 개수에 따라 스레드를 병렬로 처리 가능
- 같은 그룹의 스레드에 프로세서를 할당 또는 스레드 생성 시 중량 프로세서들 사이의 문맥 교환과 비교하여 더 경제적이다.

**단일 스레드, 다중 스레드 모델**
- 단일 스레드 프로세스 모델
  - 프로세스를 하나의 스레드, 스레드가 가진 레지스터와 스택으로 표현
- 다중 스레드 프로세스 모델
  - 프로세스를 각각의 스레드와 고유의 레지스터, 스택으로 표현, 프로세스 주소 영역을 모든 스레드가 공유
  - 프로세스의 모든 스레드는 해당 프로세서의 자원과 상태를 공유, 같은 주소 공간에 존재하며 동일한 데이터에 접근

**단일 사용자 다중 처리 시스템 환경**
- 시스템 호출이 아닌 사용자 라이브러리 수준에서 스레드 개념을 제공, 빠른 속도
- 프로그램에 비동기적 요소를 구현 가능
- 실행 중 스레드를 대기 상태로 변경, 다른 스레드로 제어를 이동시크는 상태 변화는 하나의 서버가 많은 요청을 받아들여 처리하는 효과적인 방법

**공유 메모리 형태의 다중 프로세서 시스템 환경**
- 프로그램을 공유 메모리에 저장, 스레드를 각 프로세서에 할당, 병렬 처리하여 프로세서 성능을 매우 향상시킬 수 있다.

**스레드의 단점**
- 사용자 수준 스레드는 커널 자체가 스레드 하나로 구성, 시스템 호출 실행 시 해당 스레드가 포함된 전체 작업이 시스템 호출 결과가 돌아올 때까지 대기 

**스레드의 특징**
- 준비, 실행, 대기, 종료 상태로 구분, 프로세서를 함께 사용하며 항상 스레드 하나만 실행
- 한 프로세스에 있는 스레드는 순차적으로 실행, 자신의 정보를 위한 프로그램 카운터, 스택을 가진다.
- 스레드 생성 시 운영체제는 부모 프로세스와 공유할 자원을 초기화 하지 않는다.
- 프로세서 내 스레드는 해당 프로세스에서 다른 스레드를 생성, 새로 형성된 스레드를 위한 스택과 레지스터를 제공함으로 프로세서의 생성 및 종료 과정 보다 오버헤드가 적다.
- 하나의 스레드가 대기 상태로 변할 때 전체 프로세스를 대기 상태로 변화시키지 않는다.
  - 하나의 스레드가 대기상태일 경우, 다른 스레드 실행 가능
- 서로 독립적이지 않다.
  - 한 작업에 있는 모든 스레드는 작업의 모든 주소에 접근 가능
- 보호 문제
  - 프로세서는 다수의 사용자에게서 발생, 경쟁적인 자원 요구와 서로 다른 관계 유지 
  - 스레드는 한 명의 사용자가 여러 스레드를 가진 작업 하나를 소유

**사용자 수준 스레드**
- 커널 스레드를 지원하지 않는 운영체제에서 사용
- 사용자 수준 스레드 여러개 커널 스레드(프로세스) 하나로 매핑 되는 방식
- 다중 스레드 프로세스에 대해 프로세서(실행문맥) 하나를 할당하므로 다 : 1 스레드 매핑이라 칭한다.
- 사용자 수준(공간)에서 스레드 관리가 효율적으로 이루어지므로 스레드와 관련된 모든 과정을 응용 프로그램이 수행
- 응용 프로그램은 사용자 수준 스레드 관리를 위한 루틴으로 구성된 스레드 라이브러리(스레드 패키지)를 이용, 다중 스레드로 프로그래밍 가능
- 응용 프로그램은 기본적으로 스레드 하나에서 시작, 해당 스레드에서 실행을 시작

**스레드 라이브러리**
- 스레드 생성, 종료, 문맥교환을 위한 코드, 동기화, 메모리 할당, 스레드 간 메시지 전달, 스레드 실행 스케쥴링 등의 정보를 포함
- 생성 유틸리티를 통해 스레드가 생성, 제어는 프로시저 호출을 통해 해당 유틸리티로 이동하여 수행

**사용자 수준 스레드의 장점**
- 커널 도움 없이 사용자 주소 공간에 구현된 스레드 패키지로 스레드 연산 실행
- 커널은 연산 과정을 모르고 프로세스를 계속 하나의 단위로 스케쥴하고 하나의 실행 상태를 할당
- 커널과 상관없이 다양한 목적의 응용프로그램이나 언어 인터페이스의 요구에 적용할 수 있는 융통성을 가진다.

**여러 수준에서 스레드 구현 가능**
- 운영체제에 따라 다르며 일반적으로 사용자 수준과 커널 수준, 혹은 혼합한 방식 중 하나를 사용
- 윈도우 2000/XP, Mach, OS/2, 솔라리스 운영체제는 커널 수준 지원, 시스템 호출 제공
- 사용자 수준에서 라이브러리 호출을 통한 지원 가능

**사용자 수준 스레드 이용 시 시스템의 장점**
- 높은 이식성 : 기본 커널 변경 없이 모든 운영체제에 적용 가능
- 오버헤드 감소 : 스레드 관리를 위한 모든 데이터 구조가 프로세스의 사용자 주소 공간에 있어 커널의 도움없이 스레드 교환 가능
- 스케쥴링의 유연성 : 스레드 라이브러리에서 스레드 스케쥴링을 제어하므로 스케쥴링이 응용 프로그램에 맞게 적절히 구성

**사용자 수준 스레드 이용 시 시스템의 단점**
- 시스템의 동시성 지원 불가 : 한 번에 하나의 스레드만 커널에 접근 가능, 여러 스레드가 시스템 호출을 동시에 사용할 수 없음
- 시스템 규모 확장 제약 : 커널이 프로세서 내부의 다중 스레드를 프로세스 하나로 관리, 다중 처리 환경에서 여러 프로세스를 이용한 분산 처리를 할 수 없음
- 스레드 간 보호가 어렵다 : 스레드 간 보호에 커널의 보호 기법을 사용할 수 없고, 스레드 라이브러리에서 스레드 간 보호를 제공해야 프로세스 수중에서 보호

**커널 수준 스레드**
- 사용자 수준 스레드의 한계를 해결하기 위해 사용자 스레드마다 프로세서(실행 문맥)을 매핑하는 1:1 스레드 매핑 지원
- 커널에 의해 생성, 삭제되고 커널의 텍스트와 전역 데이터를 공유, 자신만의 커널 스택을 가진다.
- 사용자 영역에는 스레드 관리를 위한 코드가 없다
  - 모든 응용 프로그램은 다중 스레드로 지원, 응용 프로그램의 스레드는 하나의 프로세스에서 지원
  - 스레드 관련 모든 작업은 커널 (운영체제) 지원, 프로세스와 스레드에 대한 실행 문맥 정보 유지

**커널 지원 부족 문제 해결**
- 커널에 의한 직접적인 스케줄링과 실행으로 사용자 수준 스레드의 문제를 해결하여 시스템 성능 향상

**병렬 실행 가능**
- 하나가 시스템 호출 시 다른 스레드가 중단되는 다 : 1 방식의 문제를 해결할 수 있어 다중 프로세서에서 다중 스레드를 병렬로 실행 가능
- 시스템 규모 확장이 쉬우며 처리량을 늘릴 수 있다.

**커널 모드 전환 오버헤드**
- 커널 스레드 생성으로 인한 오버헤드 증가로 응용 프로그램의 성능 저하를 막기 위해 시스템이 지원 스레드 수를 제한해야한다.
- 사용자 수준 스레드 보다 스케쥴링과 동기화를 위해 자원이 더 필요하다.
- 시스템이 모든 스레드를 관리하므로 오버헤드 증가

**이식성**
- 시스템 변경 시 제공된 스레드 API를 사용하여 프로그램을 수정
- 제한적인 자원으로 인해 사용자 수준 스레드 생성에 따라 커널 스레드를 무한정 생성할 수 없다.


