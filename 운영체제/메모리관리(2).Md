1. 분산 메모리 할당
###### 가. 페이징 기법
- 처리할 작업을 통일한 크기의 페이지로 나누어 처리
  - 실제 메모리를 프레임(페이지 프레임)이라 불리는 고정 크기 블록으로 나누고, 각 프로세스도 페이지라 불리는 동일한 크기의 작고 고정된 크기의 영역으로 분할
  - 연속 할당과 분산 메모리 할당 시스템
    - 연속 메모리 할당 시스템은 메모리 관리 장치(MMU)를 이용, 프로세스의 논리 메모리를 연 물리적 공간(메모리)에 저장
    - 페이징 시템은 페이지 4개로 나누어져 물리적 공간(메모리)의 임의의 장소에 각각 저장
    - 논리 메모리는 페이지와 같은 크기의 록으로 나누어진다.
    - 보조기억장치는 프레임과 같은 크기로 나누어진다.
    - 일정한 크기로 나누면 프로세스의 페이지는 보조기억장치에서 이용 가능한 프레임 안으로 적재, 효율적으로 동작

- 메 시스템에서 작업 수행을 위해 다음이 준비되어야 한다.
  - 프로그램에 소요되는 페이지를 결정하여 페이지 번호를 부여
  - 프로그램을 적재하도록 메모리의 빈 프레임을 조사하여 위치 파악
  - 프로그램의 페이지를 빈 페이지 프레임에 적재하도록 준비 

- 장, 단점
  - 빈 페이지 프레임이 어떤 작업 즉, 프로세스의 어떤 페이지에도 사용할 수 있다.
  - 효적인 메모리 사용, 페이지 프레임 간 외부 단편화가 발생하지 않음

  - 한 메모리의 여러 위치에 분산 적재
  - 페이지들의 위치 정보 등 페이지 관리가 복잡해지므로의 부담이 커진다.
  - 프레임 단위로 할당되므로 내부 단편화는 발생
  - 어떤 프로세스의 메모리 요구가 페이지 범위 내에 맞지 않으면, 할당된 마지막 프레임은 완적히 가득차지 않을 수 있다.

###### 나. 페이징 시스템 하드웨어
- 하드웨어 구조
  - 논리 페이지의 물리 메모리(페이지) 프레임 적재과정을 수행하는 페이지 시스템 하드웨어 구조
  - 프로세서의 의해 생성되는 논리 주소는 페이지번호(p)와 변위(d) 두 부분으로 나눈다.
  - 페이지 번호는 페이지 테이블에 대한 색인(p)으로 사용되어 페이지 테이블의 p위치(항목)에 저장된 f값을 얻는다.
  - f는 실제 메모리의 페이지 기준 주소로 메인 메모리의 프레임 번호가 된다.
  - 기준 주소 (f)에 페이지 변위(d)가 더해져 실제 메모리 주소(물리 주소)가 결정된다.
  - 변위는 페이지 시작위치로부터 얼마나 멀어져 있는가를 나타내는 상대 주소로 프레임 내 위치를 표시하여 페이지 프레임 크기보다 작다.

- 페이지 시스템의 물리적 주소 변환
  - 32비트의 논리적 주소(p, d)가 000250003일 경우, 페이지 번호는 25, 변위는 3
  - 페이지 테이블의 25위치(항목)에 저장된 프레임 번호는 00002, 페이지 변위가 003이므로, 생성되는 물리적 주소는 (00002#003) 16 = (00002003) 16 = (8195)19
  - 메모리에서 프레임 번호(00002)와 변위(003)의 위치를 확인 가능

- 활동중인 각 작업은 페이지 맵 테이블(PMT, Page Map Table)을 가진다.
  - 페이지 맵 테이블은 레지스터로 구성되거나 메인 메모리의 일부로 배정된다.
  - 논리 페이지는 페이지 테이블에서 해당 페이지의 프레임 번호를 확인, 실제 물리 메모리의 페이지 프레임을 찾는다.

###### 다. 페이지 번지 
- 페이지 크기는 하드웨어에 의해 정의
  - 페이지 크기는 컴퓨터 구조에 따라 페이지당 512WORD에서 2048WORD 사이로 2의 누승으로 증가
  - 페이지를 2의 누승으로 선택하는 것은 논리 주소를 페이지 번호와 페이지 변위의 변환을 쉽게 하기 위해서 이다.
  - 어떤 페이지가 2N 주소단위의 길이일 경우 논리 주소의 하위 N 비트는 페이지 변위를 나타내고, 나머지 상위 비트는 페이지 번호를 나타낸다.

- 페이지 크기는 하드웨어에 의해 정의
  - IBM 370에서 사용한 페이지 번지 
    - 32비트에서 0 ~ 7 (8비트)는 사용하지 않는다.
    - 페이지 크기가 4kb(4,069)인 경우 페이지 번호는 8 ~ 19 비트(12비트)이고, 20 ~ 31 비트(12비트)는 페이지 내 변위 (offset)이다.

- 메모리 주소 변환 과정
  - 워드 페이지를 이용한 메모리 페이징
    - 메모리의 사용자 관점에서 4워드의 페이지 크기와 32워드의 메모리(8페이지)를 사용하여 논리 주소에서 물리(메모리)주소로 사생하는 과정
    - 페이징 그 자체는 동적 재배치의 형태
    - 모든 논리 주소는 페이징 하드웨어에 의해 실제 주소로 사상
    - 페이징은 메모리의 각 프레임에 대한 기준 레지스터 테이블을 사용하는 것과 유사하다.

  - 논리 주소 0은 페이지, 변위 0
  - 페이지 테이블 색인으로 찾아서 페이지 0이 프레임 5에 있는 것을 확인
  - 논리 주소 0은 메모리 주소 20( = 5 * 4 + 0 )으로 사상
  - 논리 주소 3(페이지 0, 변위 3)은 메모리 주소 23 ( = 5 * 4 + 3 )으로 사상

- 논리 주소 4는 페이지 테이블에 의해 페이지 1, 변위 0이며, 페이지 1은 프레임 6으로 사상
  - 메모리 주소 24 ( = 6 * 4 + 0 )으로 사상하며, 논리 주소 13은 메모리 주소 9로 사상

###### 라. 다중 계층 페이징
- 페이지 테이블 n-단계 계층 구조로 구성
  - 논리 주소에서 물리 주소로 변환하는 과정에서 가상주소공간의 크기가 커질수록 페이지 테이블의 크기가 증가하므로 메인 메모리에 보다 큰 적재 공간을 요구한다.
  - 32비트의 환경의 프로세스는 메모리도 32비트에 해당하는 4g까지 사용가능하다.
  - 페이지의 크기가 4kb으로 정의하여 관리할 경우, 4gb/4kb = 1048576
  - 4gb의 메모리 공간을 4kb 크기의 페이지로 나누어 관리하기 위해 필요한 페이지 테이블은 1,049,576
  - 페이지 테이블을 유지하기 위해 발생하는 메모리 낭비를 막기 위해 사용
  - 20^20 = 1,048,576 이고, 1개의 페이지 테이블 항목(PTE, Page Table Entry)은 4바이트이므로 페이지 테이블이 차지하는 메모리 크기는 4mb ( = 1,048,576 * 4byte)
  - 하나의 프로세스가 4gb의 메모리 공간을 관리하는 페이지 테이블을 유지하기 위해 4mb가 필요하다.
  - 페이지 테이블을 n-단계 계층구조로 구성하여, 실제 참조할 페이지들이 존재하는 영역에 대해서만 단계별 페이지 테이블을 설정하여 처리한다.
  - 한 번에 20비트를 사용한 대신 10비트씩 나누어서 사용하면 210 = 1,024이므로 한 항목은 4바이트, 전체적으로 4kb( 1024 * 4 = 4,096)를 사용하게 되므로 1프레임(4kb)로 해결 가능

- 다중 계층 페이징 기법
  - 논리주소 '000000001 0000000011 0001100100100' 에 대한 다중 계층 페이지 처리 과정
  - 하위(0-11) 12비트는 변위 (840)이며 중간(12-21) 10비트는 페이지 테이블 색인(3), 상위(22-31) 10비트는 페이지 항목 (디렉토리) 색인 (1)을 나타낸다.

###### 마. 페이지 스케줄링
- 프로세스 수행을 위해 준비 큐에 도착 시, 프로세스의 크기는 페이지 단위로 표현
- 장기 스케줄러는 할당되지 않은 빈 페이지 프레임 리스트를 유지, 이용 가능한 상태로 준비한다.
- 프로세스가 페이지 n개를 요구할 경우,
  - 메모리에서 이용할 수 있는 n개의 빈 프레임이 있어야 한다.
  - 프레임 n개를 사용 가능할 경우 장기 스케줄러가 프레임을 프로세스에 할당한다.
- 최초 페이지는 할당된 프레임 중 하나에 적재, 프레임 번호는 페이지 테이블 속에 기록된다.
  - 다음 페이지는 다른 프레임에 적재, 프레임 번호는 페이지 테이블에 기록

- 사용가능 프레임 리스트에 있는 프레임에 새로운 작업 할당 과정

###### 바. 페이지 테이블의 구현
- 전용 레지스터를 사용하여 구현
  - 페이징 주소변환을 매우 효율적으로 하기 위해 초고속 논리 회로로 설계
  - 효율성이 주요 고려 대상
    - 메모리의 모든 액세서는 페이징 테이블 정보에 의해 수행
  - 페이지 테이블 항목이 적을수록 관리(하드웨어 비용 감소)가 쉬움

- 페이지 테이블 기준 레지스터(PTBR, Page Table Base Register)
  - 기존 컴퓨터는 페이지 테이블이 매우 크므로, 레지스터로 구현이 적합하지 않는다.
  - 페이지 테이블을 메모리에 유지, 페이지 테이블 기준 레지스터가 페이지 테이블을 지시
  - 하나의 레지스터 값 변화로 페이지 테이블이 변경, 실제적인 문맥교환시간 감소
  - 메모리 액세스 시간 문제
    - 페이지 테이블 항목과 워드를 위한 메모리 액세스가 필요하며, 이로 인해 속도가 느려진다.
    - 연관 레지스터 또는 변환 우선참조버퍼(TLBS, Translation Look-aside Buffers)를 이용

  - 사상 방법에 따른 주소 변환
    - 직접 사상에 의한 페이지 주소 변환
    - 연관 사상에 의한 페이지 주소 변환
    - 연관/직접 사상을 결합한 페이지 주소 변환

  - 직접 사상에 의한 페이지 주소 변환
    - 완전한 페이지 사상표가 메인 메모리 또는 고속의 캐시 메모리에 유지

  - 가상 주소 v = (p,d)를 참조하는 과정
    - 프로세스의 페이지 테이블에 있는 메인 메모리 주소를 페이지 테이블 기준 레지스터에 로드
    - 가상 주소에 대응하는 메모리 주소를 얻기 위해 페이지 테이블 시작 주소 b를 참조 페이지 번호 p에 더하여 페이지 테이블(b)내의 색인 p에 관한 메모리 주소 p를 얻는다.

###### 바. 페이지 테이블의 구현
- 직접 사상에 의한 페이지 주소 변환
  - 완전한 페이지 사상표가 메인 메모리 또는 고속의 캐시 메모리에 유지
  - 가상 주소 v = (p,d)르 ㄹ참조하는 과정
    - 페이지 프레임 p가 가상페이지(페이지 번호) p에 대응하는 것을 가리킨다.
    - p는 변위 d와 접속, 메모리 주소 r ( = p + d )를 얻는다.

  - 가상 주소 v가 n개의 페이지를 포함할 경우
    - 사상되는 페이지 테이블은 페이지1, 페이지2 ..... 페이지 n - 1 에 해당하는 항목을 가진다.
  - 페이지 테이블 변경은 레지스터 변화로 가능
    - 메인 메모리에 작성하여 페이지 테이블 기준 레지스터가 페이지 테이블을 지정하는 방법이 바람직

  - 문제점
    - 사용자 메모리 위치에 액세스하는데 소요되는 시간
    - 주소 p에 액세스 하기를 원할 경우, 먼저 p에 대한 페이지 번호의 페이지 테이블 기준 레지스터 변위값을 사용, 페이지 테이블로 색인
    - 하나의 워드에 액세스하려면, 페이지 테이블을 위해 그리고 워드를 위한 두 변의 메모리 액세스가 필요
    - 메모리 액세스는 두 배로 느려짐

  - 지연에 대한 해결 방법
    - 연관 레지스터 또는 보조예비기억장치라 불리는 하드웨어 메모리 사용

- 연관 사상에 의한 페이지 주소 변환
  - 프로세서에 의해 생성된 논리 주소는 연관 레지스터의 집합으로 표현
  - 각 레지스터는 키와 값으로 구성
  - 연관 레지스터에 항목 표현과 동시에 모든 키와 비교, 항목이 발견되면 대응하는 값 부분 출력
  - 페이지 테이블 기준 레지스터(PTBR)은 필요하지 않는다.

- 순수 연관 사상을 통한 페이지 주소 변환
  - 페이지 p를 찾기 위해 연관 메모리의 모든 항목을 동시에 조사
  - 해당 페이지 프레임 p가 발견되면 d와 접속, 메모리 주소 형성
  - 연관 사상표로 향하는 화살표들이 실제로 사상표의 모든 단위 항목으로 표시
  - p와 일치하는 것을 찾기 위해 연관 메모리의 모든 단위 항목을 동시에 조사함을 의미
  - 이로 인해 연관 메모리가 비싸진다.

- 연관/직접 사상을 통한 페이지 주소 변환(1/3)
  - 최근 페이지만을 연관 메모리에 유지, 연관 메모리에 그 페이지가 없을 때 직접 사상 방법 제안
  - 지역성을 이용, 최근 참조된 페이지는 곧 다시 사용된다는 것을 적절하게 이용

- (2/3)
  - 현재 수행 중인 프로그램이 페이지 p를 찾기 위해 연관 메모리의 모든 항목을 동시에 조사
  - 페이지 p에 해당되는 페이지 프레임 p가 발견되면 d와 접속, 메모리 주소 r = p + d를 얻는다.

- (3/3)
  - p와 일치하는 항목이 연관 사상표에 없는 경우 논리 주소의 페이지 번호(p)를 페이지 테이블 기준 레지스터의 b와 합하여 p * b 의 직접 페이지 테이블의 p에 대응하는 페이지 프레임 p를 얻는다.
  - 이어서 p + d 의 메모리 주소 r을 생성

- 적중률
  - 페이지 번호가 연관 레지스터에서 발견될 비율
  - 적중률 80%일 경우 (26.6% 늦어진다.)
  - 적중률 90%일 경우 (유효 접근 시간 = 875ns)
    - 증가된 적중률은 메모리 액세스 시, 16.6%로 적중률 80%보다 10& 감소된다.
  - 적중률은 연관 레지스터의 수와 관계
    - intel 80486 프로세스는 레지스터 32개, 적중률 98%

###### 사. 공유 페이지
- 시분할 환경에서 중요한 공통된 코드를 공유할 수 있다.
  - 사용자 40명을 지원하는 시스템에서 각 사용자가 문장 편집기를 수행하는 경우
  - 문장 편집기는 200kb 크기의 코드와 50kb의 데이터 공간으로 구성
  - 사용자 40명을 지원하기위해 9.8mb (= 200 + 50 ) * 40 = 10,000kb가 필요
  - 만약 코드가 변경할 수 없는 코드(재진입 가능 코드)인 경우 그림과 같이 (ed1, ed2, ed3)를 공유할 수 있다.
  - 세 개의 페이지 편집기 ed1, ed2, ed3와 각 프로세스는자신의 데이터 페이지를 가진다.

- 재진집 코드(Pure Code)
  - 스스로 수정하지 못하는 코드로 재진입하면 수행 도중 변하지 않는다.
  - 두 개 또는 그 이상의 프로세스가 동시에 같은 코드 수행 가능
  - 각 프로세스는 수행을 위해 자신의 데이터가 있는 저장 장소, 레지스터의 복사본과 프로세스에 필요한 각각의 데이터를 가진다.
  - 40명의 사용자를 지원하기위해 단 하나의 편집기 복사본(200kb)와 각 사용자를 위한 데이터 공간 50kb를 소요하는 복사본 40개가 필요
    - 실제 요구되는 총 공간은 9.8mb가 아닌 2.1mb ( 50 * 40 + 200 = 2200kb = 2.1mb )

###### 아. 메모리 보호
- 페이지 테이블 속 한 개의 보호용 비트에 의해 수행, 각 페이지와 연관
  - 1비트는 한 페이지가 읽기/쓰기 또는 읽기 전용 임을 정의할 수 있다.
  - 보호용 비트들이 쓰기 기능(write)을 읽기 전용 페이지에서 수행하지 않음을 검증
  - 대부분 페이지 기법에서 메모리에 대한 접근은 페이지 테이블을 먼저 실행, 프레임 번호를 찾으며 동시에 메모리 주소가 계산
  - 읽기 전용 페이지의 기록에 대한 액세스는 운영체제의 하드웨어트랩(메모리 보호위반)을 가져온다.

- 페이지 테이블 액세스 허용/비허용
  - 페이지 테이블 영역에 보호용 비트 1개를 설정, 액세스의 종류에 따라 타당/비타당 여부를 확인하여 불법적인 시도를 운영체제에서 트랩하는 과정

###### 자. 페이징에 대한 견해
- 사용자의 메모리에 대한 관점과 메모리 분리가 중요
  - 메모리의 사용자 관점에서 실제 메모리 사이의 차이점은 주소변환 하드웨어에 의해 논리 주소를 실제 주소로 변환 조정

- 장점
  - 공유 페이지의 이용, 외부 단편화 제거(내부 단편화는 발생), 메모리 활용을 통한 다중처리프로그래밍 실현, 압축 기능 제거 등

- 단점
  - 페이지 사상을 위한 하드웨어 준비로 인한 가격 상승과 속도 저하 그리고 내부 단편화 발생

2. 세그먼트 메모리 관리 기법
###### 가. 세그먼트 메모리 관리 기법
- 메모리의 사용자 관점 지원
  - 메모리는 크기를 변경 가능한 세그먼트 단위 모음
  - 고정 크기를 갖는 페이징과는 다르다.
  - 메모리를 일반적으로 프로그램을 구성하는 서부 루틴(Sub-routine), 프로시저(Procedure), 함수(Function), 모듈(Module) 등의 각각 다른 크기를 갖는 세그먼트로 나눈다.
  - 각 세그먼트는 연관된 기능을 수행하는 하나의 모듈 프로그램
  - 각 세그먼트는 연속된 위치에 구성되나, 메모리에서 서로 인접할 필요는 없음

###### 나. 세그먼트 메모리 할당
- 논리 구조 공간을 세그먼트의 모임으로 인식
  - 세그먼트는 일반적으로 컴파일러(어셈블러)가 자동적으로 입력프로그램(원시 프로그램)을 이용하여 작성
  - 하드웨어 보호 등 관리에 필요한 세부 사항은 페이징과 비슷하거나 동일
  - 동적 분할(가변 분할) 기법으로 메모리를 할당
    - 프로세스에 따라 세그먼트 크기가 다르므로 메모리가 일정한 크기의 페이지 프레임으로 나누지 않늗나.
  - 인텔 8060은 세그먼테이션을 자신의 유일한 메모리 관리 기법으로 지원
    - 프로그램은 코드, 데이터, 스택, 세그먼트로 분리

###### 다. 세그먼트 번지와 세그먼트 테이블 구현
- IBM 370에서 구성한 세그먼트 번지
- 세그먼트 테이블은 메인 메모리에 유지
  - 프로세스의 크기에 다라 길이가 가변적, 레지스터에 정보를 유지하기 어렵다.
- STBR(Segment Table Base Register) "메모리에 있는 세그먼트 테이블의 주소"
- STLR(Segmetn Table Length Register) "프로그램에 의해 사용되는 세그먼트 수"

###### 라. 하드웨어 구조
- 세그먼트의 논리 주소는 세그먼트 번호 s와 세그먼트 내의 변위 d로 구성
  - 세그먼트 번호 s는 세그먼트 테이블에 대한 색인으로 사용
  - 세그먼트 테이블의 각 항목은 세그먼트의 기준(sb)와 세그먼트의 한계(sl), 즉 크기(길이)를 가진다.
  - 세그먼트 주소의 변위 d는 0과 sl 사이의 값이어야한다.
  - 변위가 할당된 경우 (d(sl)) 세그먼트 기준(sb)과 변위(d)가 더해져 메모리 주소를 만든다.

- 세그먼트의 논리 주소는 세그먼트 번호 s와 세그먼트 내의 변위 d로 구성

###### 마. 세그먼트 공유
- 공유한다고 선언(정의)하면 공유가 이루어진다.
  - 두 개 이상의 다른 프로세스의 세그먼트 테이블 속에 항목들이 같은 메모리 주소를 지정하면 공유된다.
  - 공유 기능을 사용하는 시스템은 적절한 보호체계를 제공, 승인된 사용자만 액세스 가능하도록

- 문서 편집기에 대한 공유 과정
  - 각 세그먼트 테이블에서 메모리의 같은 세그먼트(43063)을 지정하여 공유

###### 바. 단편화
- 모든 세그먼트에 대한 적당한 기억 장소를 찾아 할당
  - 페이징 시스템의 일정한 크기(페이지)에 비해 세그먼트 기법은 크기가 변환
  - 최상 적합 알고리즘이나 최초 적합 알고리즘을 사용하여 해결되는 동적 메모리 할당 방법 이용
  - 외부 단편화 발생 가능
    - 사용 가능 메모리의 모든 블록들이 너무 작아 세그먼트를 수용할 수 없는 경우
    - 단순히 기다리거나 압축하여 더 큰 공간 생성
    - 동적 재배치 알고리즘이므로 원할때마다 메모리를 압축 가능

###### 사. 페이지화된 세그먼트 메모리 할당
- 페이징 세그먼트의 장단점
  - 페이징
    - 내부 단편화 현상을 가진다.
    - 메모리를 효율적으로 사용 가능하며, 동일한 크기의 작업을 가지므로 많은 알고리즘 개발 가능
  - 세그먼트
    - 외부 단편화 현상을 가진다.
    - 가변적인 데이터 구조와 모듈 처리, 공유와 보호의 자원이 편리

- 페이지화된 세그먼트 메모리 할당
  - 페이징과 세그멘테이션의 결합된 구정
  - 외부 단편화 문제를 제거하면서 할당 과정을 쉽게 해결
  - 멀틱스(Multics) 시스템에서 사용, 인텔 386 계열에서도 사용

  - 멀틱스 시스템의 세그먼트 논리 주소
    - 18비트의 세그먼트 번호와 16비트의 변위로 구성, 변위는 6비트의 페이지 번호와 10비트의 페이지 변위로 구성
    - 프레임 번호는 페이지 변위와 결합, 메모리 주소를 산출

- 세그먼트 메모리 주소 변환
  - 각 프로세스는 하나의 세그먼트 테이블을 가지며, 각 세그먼트는 자신의 페이지 테이블을 가진다.
  - 특정 프로세스가 실행중일 때, 하나의 레지스터가 프로세스에 대한 세그먼트 테이블의 시작 주소를 가진다.
  - 각 세그먼트의 마지막 페이지는 완전히 차지 않으므로 내부 단편화가 발생 가능
  - 외부 단편화 제거되나, 내부 단편화는 계속 발생되며, 테이블 공간에 대한 부담 증가
  - 복잡하며 각 사용자의 메모리를 3번 참조한다.


