# 프로세스, 스레드

**1960년대 멀틱스 시스템 설계자 처음 사용**
- 이후 작업이란 용어와 함께 사용되며, 다양한 정의를 가진다.
- 가장 일반적인 정의는 **실행 중인 프로그램**
  - 디스크에 저장되어 있던 실행 가능한 프로그램이 메모리에 적재되어 운영체제의 제어를 받는 상태
  - 해당 프로세스가 사용하고있는 메모리 영역 (자신의 주소 공간 ) 이 존재함을 의미한다.
  - 프로세서 할당 ( 점유 ) 시간과 메모리, 파일, 입출력장치 등의 자원이 필요하며, 자원은 프로세스 생성 및 실행 시 할당
  - 현재의 활동 상태를 나타내는 프로그램 카운터, 프로세서의 현재 활동 ( 레지스터 내용 ) 포함

**프로그램과 달리 프로세서는 메모리에 주소 공간을 갖는 능동적인 개체**
- 실행 스택 ( Stack ) : 호출된 프로시저 ( 함수 )의 복귀 주소와 지역변수 등의 일시적인 데이터를 저장하는 영역
- 실행 힙 ( Heap ) : 텍스트 ( 코드 ) 영역과는 별도로 유지되는 자유 영역
- 데이터 ( 정적 변수 ) : 프로세스 실행 중 동적으로 할당 받는 영역, 전역 또는 정적 변수 저장
- 텍스트 ( 코드 ) : 프로세서가 실행하는 코드 저장
- 메모리 내에 동일한 사본을 여러 사용자가 공유할 수 있도록 작성된 프로그램, 루틴
  - 실행 중 사용할 데이터를 보관하는 실행 스택과 공통적인 데이터를 보관하는 데이터 영역을 가진다.
  - 프로세서가 동일한 프로그램을 사용하여도 텍스트 ( 코드 ) 영역은 같으나 별도의 스택에 서로 다른 데이터를 가지므로 별개의 프로세스로 인식
  - 데이터베이스, 문서 편집기 등

**프로세서는 사용자 관점에서 세그먼트 ( 코드, 데이터, 스택 )의 가상 주소 공간을 갖는 상태를 의미, 시스템 관점에서 실행 중인 프로그램을 의미**
- 처리 상태에 있는 데이터 구조로 표현 가능
  - 스케줄러 ( 디스패치 )에 의해 프로세서 할당
  - 파일에 관련된 자원에 대한 참조 ( 장치 관리, 메모리 관리 )
  - 프로세스 지원과 협력에 관한 정보 ( 교착상태, 보호, 동기화 ) 교환
  - 프로세스 관련 연산은 생성, 종료, 보류, 자원 할당, 해제 등

**실행 유형에 따라 크게 3가지로 구분**
- 운영체제 프로세스
  - 커널 프로세스, 시스템 프로세스라 부른다.
  - 프로세스 실행 순서 제어, 사용하고 있는 프로세스가 다른 사용자나 운영체제 영역을 침범하지 못하게 감시하는 기능 담당
  - 사용자 프로세스 생성, 입출력 프로세스 등 시스템 운영에 필요한 작업 수행 

- 사용자 프로세스
  - 사용자 코드 수행

- 병행 프로세스
  - 독립 프로세스
    - 프로세스 여러개가 병행하여 수행 시 주어진 초기값에 따라 항상 같은 결과를 보여준다.
    - 서로 독립적으로 실행되어 다른 프로세스에 영향을 받지 않고 데이터를 공유하지 않는다.
  - 협동 프로세스
    - 다른 프로세스에 영향을 주거나 다른 프로세스에 의해 영향을 받는다.
    - 컴퓨터 시스템의 제한된 자원을 공유하는 프로세스들이 통제되어 상호 작용해야하는 경우 발생

**실행, 비실행 프로세스 구분**
- 프로세스는 실행되며 상태가 변하므로 운영체제는 프로세스 제어에 필요한 프로세스 상태를 점검해야한다.
  - 운영체제가 프로세스를 새로 생성하면 비실행 상태로 초기화 되어 실행을 기다린다.
  - 실행 중인 프로세스 종료, 인터럽트 발생 시 비실행 프로세스 중 선택된 프로세스가 실행 상태로 변하고 (디스패치) 인터럽트 된 프로세스는 비실행 상태로 변경
- 실행 상태 프로세스
  - 실행 : 명령어가 실행되는 상태, 즉 프로세스가 프로세서를 점유한 상태
  - 대기, 보류 : 프로세서가 이벤트 ( 입출력 종료와 같은 외부 신호 )가 일어나길 기다리는 상태
  - 준비 : 프로세스가 프로세서를 할당 받기 위해 기다리는 상태
- 대부분의 프로세스는 준비, 대기(보류)상태이며, 어느 한 순간에 한 프로세스만 실행 상태가 된다.
- 시스템의 모든 프로세스는 종료되어 시스템을 떠날 때까지 준비, 실행, 대기 상태로 변화되며 실행되는 과정을 반복
- 운영체제는 프로세서 스케쥴러를 이용해 프로세스 상태를 변화를 관리한다.

**작업 스케쥴러**
- 스풀러가 디스크에 저장한 작업들 중 실행할 작업을 선정, 준비 리스트에 삽입
- 이를 통해 다중 프로그래밍의 정도를 결정하는 핵심적인 역할 수행
- 선정한 작업에 대한 프로세스의 생성에서 종료까지의 과정 수행을 위해 상태 변화를 일으킨다.
- 실행 프로세스가 자발적으로 프로세서 반환 전 할당된 시간이 경과하면 준비상태로 변경
- 실행 프로세스가 실행하다 입출력 명령이 발생 시 대기 상태로 변경
- 대기 프로세스는 보류 이유가 제거되면 준비 상태로 변경
- 준비 프로세스는 디스패치가 프로세서를 할당하면 다시 실행상태로 변경

**준비 >> 실행**
- 디스패치 : 준비 리스트 맨 앞에 있던 프로세스가 프로세서를 선택 ( 배당되어 실행 ) 하는 것
- 시간할당
  - 실행 프로세스가 프로세서를 일정 시간만 사용할 수 있도록 시간을 제한
  - 특정 프로세스가 프로세서를 계속 독점하는 것을 방지한다.

**실행 >> 준비**
- 프로세스가 프로세서를 점유한 상태를 "프로세스가 실행 상태에 있다" 라고 한다.
- 운영체제는 프로세스의 독점을 방지하기 위해 인터럽트 클록을 둔다.
  - 특정 프로세스가 일정 시간이 지나도 ( 타임 아웃) 프로세서를 반환하지 않으면 클록이 인터럽트를 발생. 운영체제가 프로세서 제어권을 가진다.
  - 운영체제가 제어권을 가지면 실행 중인 프로세스는 준비 상태로 변화, 준비 리스트의 첫 프로세스가 실행 상태로 변경

**실행 >> 대기(보류)**
- 실행 프로세스가 지정 시간 전에 입출력 연산 등이 필요하거나 새로운 자원 요청 등의 문제 발생 시 스스로 프로세서를 양도하고 대기 상태로 변경

**대기 >> 준비**
- 깨움(wake UP) : 프로세스의 마지막 상태 변화로 입출력 작업이 끝났을 때 발생

**프로세스의 교환은 인터럽트와 트랩, 시스템 호출로 나타낸다**
- 실행 중인 프로세스가 인터럽트 되어 운영체제가 다른 프로세스를 실행 상태로 변경, 제어를 넘겨줄 때 프로세서의 레지스터 내용은 저장해야한다.
- 프로세스는 현재 사용되는 자원에 대한 정보를 가지며, 실행되는 과정에서 여러 프로세스가 파생될 수 있는 능동적인 개체
  - 프로그램은 프로세스 여러 개로 생성될 수 있는 디스크에 저장된 파일 내용으로 정적 단위
- 자원을 할당 받은 상태의 프로그램

_프로세스 관리_
- 실행 중 프로세스 생성 시스템을 호출, 새로운 프로세스를 생성 가능
- 프로세스 생성 순서 저장, 부모 ~ 자식 관계를 유지하며 계층적으로 생성된다.
  - 부모 프로세스 : 생성하는 프로세스
  - 자식 프로세스 : 생성되는 프로세스
- 유닉스 시스템의 일반적인 프로세스 계층 구조
  - 처음 부팅 시 식별자가 0인 첫 번째 프로세스 Swapper 생성
  - Init(PID = 1) Pagedeamon(PID = 2) 생성
  - Swapper(PID = 0) Pagedeamon(PID = 2)를 운영체제 프로세스라 하며 운영체제 모드에서만 실행
  - 모든 사용자 프로세스는 FORK() 명령을 통해 계층적으로 Init의 자식 프로세스 

**프로세스는 운영체제, 다른 사용자의 응용 프로그램 요청에 의해 생성**
- 운영체제가 새로운 프로세스를 생성, 추가하려면 프로세스 관리를 위한 프로세스 제어 블록을 만든 후 프로세스에 주소 공간을 할당해야 한다.
  - 일괄 처리 환경에서는 실행을 위해 작업이 준비 큐에 도착할 때 생성
  - 대화형 환경에서는 새로운 사용자가 로그온 할 때 생성
  - 프로세스 생성을 위한 작업
    - 프로세스 식별자 결정
    - 시스템에 알려진 프로세스 리스트에 식별자 삽입
    - 프로세스에 초기 우선 순위 부여
    - 프로세스 제어 블록 생성
    - 프로세스에 초기 자원 할당

**프로세스가 작업을 수행하기 위해 자원 필요**
- 자식 프로세스 생성 시 필요한 자원을 운영체제로부터 직접, 부모 프로세스의 자원 일부 사용 가능
- 부모 프로세스는 자식 프로세스에 자원을 나눠주거나 일부 자원 공유 가능
  - 자원의 일부만 사용하도록 제한하면 시스템에 부담을 주는 것을 방지 가능하다.
  - 프로세스 생성 시 획득하는 다양한 물리적, 논리적 자원 외에도 약간의 초기화 데이터가 부모 프로세스에서 자식 프로세스로 전달되는 경우도 있다.

**새로운 프로세스 생성 시 실행과 관련해 다음 두 가지 경우가 가능하다**
- 부모 프로세스, 자식 프로세스가 동시에 실행
- 부모 프로세스, 자식 프로세스들이 모두 종료될 때 까지 기다린다.
- 자식 프로세스가 부모 프로세스의 주소공간을 복사
  - 유닉스는 각 프로세스마다 정수로 된 고유한 프로세스 식별자를 가진다.
  - 새로운 프로세스는 fork()명령에 의해 생성, 주소 공간은 부모 프로세스의 주소 공간을 복사한다.
  - 부모 프로세스, 자식 프로세스의 정보 교환이 쉽다.
- 자식 프로세스가 별도의 프로그램을 적재

"윈도우 NT 계열은 새로운 프로세스의 주소 공간을 두 가지 방식을 모두 지원"

**프로세스가 명령 실행 후 종료되고 운영체제에 프로세스 삭제 요청**
- 일괄 처리 환경 : 작업 종료를 의미하는 신호로 인터럽트 발생 또는 시스템 호출로 중지 명령 전달, 프로세스 완료
- 대화형 환경 : 사용자가 로그오프 하거나 터미널을 닫을 때, 오류에 의해 프로세스 종료
- ABORT 시스템 호출을 이용한 프로세스 종료
  - 종료되는 프로세스를 생성한 부모 프로세스만 호출 가능
  - 부모 프로세스가 자식 프로세스의 생존권을 가져 다른 프로세스가 임의로 작업을 중단 시킬 수 없다.
  - 자식 프로세스 종료 시 자식 프로세스의 신원이 부모 프로세스로 전달

**부모 프로세서는 아래의 이유로 자식 프로세스 종료 가능**
- 자식 프로세스가 할당된 자원을 초과하여 자원을 사용할 때
- 자식 프로세스에 할당된 작업이 더 이상 없을 때

**연속 종료**
- 시스템이 부모 프로세스 종료 시 자식 프로세스의 존재를 허용하지 않아 종료시키는 현상으로 운영체제가 수행한다.
  - 유닉스에서 exit 명령으로 프로세스 종료, 부모 프로세스는 wait 명령을 사용하여 자식 프로세스의 종료를 기다린다.
  - wait : 종료된 자식의 프로세스 식별자를 부모 프로세스에 전달한다.

**프로세스를 종료하는 경우, 그 예**
- 정상 종료 : 프로세스가 운영체제의 서비스를 호출한 경우
- 시간 초과 : 프로세스가 명시된 전체 시간을 초과하여 실행되거나 명시된 시간을 초과하면서 어떤 이벤트 발생을 기다리는 경우
- 실패 : 파일 검색 실패, 명시된 횟수를 초과하여 입출력이 실패한 경우
- 산술 오류, 보호 오류, 데이터 오류 등
- 메모리 부족, 접근 위반 등

**프로세스를 파괴하는 것**
- 제거 시 프로세스에 속한 자원을 시스템에 돌려주고 해당 프로세스는 시스템 리스트나 테이블에서 사라지며, 프로세스 제어 블록 회수
- 프로그램은 디스크에 저장된다.

**프로세스 중단(일시 정지**
- 프로세서의 동작 시간과 입출력 동작 시간의 차이로 시스템의 활동 시간이 유휴 상태로 되는 것을 해결 가능하다.
- 장시간 중단되는 경우 해당 프로세스에 할당된 자원을 다시 풀어 주어야 하며, 풀어줄 자원의 결정은 자원의 성질에 따라 결정
- 다중 프로그래밍에서 중단은 자원 부족 (대기) 상태를 의미하기도 한다.
  - 다중 프로그래밍 환경에서 자원의 이용률과 시스템 효율 향상을 위해 자원을 동적으로 할당
  - 교착 상태 발생 시 문제 생김
  - 중단 : 할당된 자원을 기다리는 상태
  - 대기 : 자원을 할당 받기 위해 기다리는 상태

**운영체제는 다음 두 가지 방법으로 프로세스를 실행 가능**
- 새로운 프로세스를 생성하여 실행
- 이미 실행 중인 프로세스를 중단시켰다가 다시 실행
  - 시스템 전체의 부하를 증가시키지 않으면서 프로세스에 서비스 제공 가능
  - 특정 이벤트 발생을 기다리며 대기 상태가 되므로 해당 이벤트 발생 시 즉시 실행 상태로 변화 가능

**프로세스 재시작**
- 중단 원인이 제거되어 프로세스가 다시 실행되는 것 
- 중단 되었던 프로세스는 중단되었던 지점부터 다시 시작

**프로세스 중단과 재시작이 발생하는 경우**
- 시스템에 장애가 발생하면 실행 중인 프로세스는 잠시 중단했다가, 시스템이 기능을 회복했을 때 다시 재시작할 수 있다.
- 프로세스의 어느 부분이 의심스러울 때 사용자는 실행 중인 프로세스를 중단하여 확인한 후 재시작하거나 정지할 수 있다.
- 처리할 일이 많아 시스템 부담이 크면 프로세스 몇 개를 중단했다가 시스템이 정상상태로 돌아올 때 다시 재시작 할 수 있다.

_중단과 재시작을 추가한 프로세스 상태변화_
- 중단 : 프로세스 자신, 다른 프로세스에 의해 가능
- 단일처리시스템 : 프로세스 자신이 중단시켜야한다.
- 다중처리시스템 : 다른 프로세서에 의해서도 가능하지만, 다른 프로세서가 재시작시켜주기전에 실행 불가능

**프로세스 제어 블록의 우선 순위 값 변경가능**
- 준비 리스트의 프로세스는 프로세서 중심 프로세스 (낮은 우선 순위), 입출력 중심 프로세스 (높은 우선 순위)로 구분
  - 우선 순위가 낮은 프로세스 : 시간 할당량을 크게 제공
  - 우선 순위가 높은 프로세스 : 시간 할당량을 적게 제공  
_입출력 중심의 프로세스를 자주 짧게 사용, 프로세서 중심 프로세스는 사용 횟수는 적으나 한번에 오래 사용하게 하여 균형을 유지한다._  
- 입출력 프로세스
  - 높은 우선 순위 : 속도가 느리면서 빠른 응답을 요구하는 단말기 입출력 프로세스
  - 낮은 우선 순위 : 속도가 빠른 디스크 입출력 프로세스
- 프로세스 스케줄러는 준비 리스트의 우선 순위를 이용해 프로세스를 처리
- 할당 시간을 초과할 경우 프로세스 실행 상태에서 준비 상태로 변경
- 실행 중인 프로세스가 인터럽트 되면 운영체제가 다른 프로세스를 실행 상태로 변경, 해당 프로세스에 제어를 넘겨주는 과정에서 실행 중인 프로세스로 부터 제어를 인수한 운영체제가 또 다른 프로세스에 제어를 넘겨주기 위해 발생
  - 인터럽트 처리 루틴을 실행한 후 현재 실행 중인 프로세스가 재실행될 수 있으므로 대부분의 운영체제는 프로세스 교환으로 인터럽트가 발생하지 않는다.
  - 트랩은 시스템이 치명적인 오류인지를 판단, 치명적 오류일 경우 프로세스를 종료하고 프로세스 교환 발생
- 프로세스를 다른 프로세스로 교환하기위해 이전 프로세스의 상태 레지스터 내용을 보관하고 다른 프로세스의 레지스터를 적재하는 일련의 과정

**인터럽트(Interrupt)**
- 현재 실행되는 프로세스와 별도로 외부에서 발생되는 여러 종료의 이벤트 (입출력 동작의 종료 등)에 의해 발생
- 제어가 인터럽트 처리 루틴으로 넘어간 후에도 기본 시스템 관리 작업을 처리, 인터럽트 형태에 따라 관련된 운영체제 루틴으로 분기
- 입출력 인터럽트
- 클록 인터럽트 : 현재 실행 중인 프로세스의 할당 시간을 조사하여 실행 중인 프로세스를 준비 상태로 변경, 다른 프로세스를 디스패치하여 실행 상태로 변경

**트랩**
- 부적절한 파일 접근, 현재 실행 중인 프로세스에 의해 발생되는 오류나 예외 상황으로 인해 발생
