# 프로세스, 스레드

**1960년대 멀틱스 시스템 설계자 처음 사용**
- 이후 작업이란 용어와 함께 사용되며, 다양한 정의를 가진다.
- 가장 일반적인 정의는 **실행 중인 프로그램**
  - 디스크에 저장되어 있던 실행 가능한 프로그램이 메모리에 적재되어 운영체제의 제어를 받는 상태
  - 해당 프로세스가 사용하고있는 메모리 영역 (자신의 주소 공간 ) 이 존재함을 의미한다.
  - 프로세서 할당 ( 점유 ) 시간과 메모리, 파일, 입출력장치 등의 자원이 필요하며, 자원은 프로세스 생성 및 실행 시 할당
  - 현재의 활동 상태를 나타내는 프로그램 카운터, 프로세서의 현재 활동 ( 레지스터 내용 ) 포함

**프로그램과 달리 프로세서는 메모리에 주소 공간을 갖는 능동적인 개체**
- 실행 스택 ( Stack ) : 호출된 프로시저 ( 함수 )의 복귀 주소와 지역변수 등의 일시적인 데이터를 저장하는 영역
- 실행 힙 ( Heap ) : 텍스트 ( 코드 ) 영역과는 별도로 유지되는 자유 영역
- 데이터 ( 정적 변수 ) : 프로세스 실행 중 동적으로 할당 받는 영역, 전역 또는 정적 변수 저장
- 텍스트 ( 코드 ) : 프로세서가 실행하는 코드 저장
- 메모리 내에 동일한 사본을 여러 사용자가 공유할 수 있도록 작성된 프로그램, 루틴
  - 실행 중 사용할 데이터를 보관하는 실행 스택과 공통적인 데이터를 보관하는 데이터 영역을 가진다.
  - 프로세서가 동일한 프로그램을 사용하여도 텍스트 ( 코드 ) 영역은 같으나 별도의 스택에 서로 다른 데이터를 가지므로 별개의 프로세스로 인식
  - 데이터베이스, 문서 편집기 등

**프로세서는 사용자 관점에서 세그먼트 ( 코드, 데이터, 스택 )의 가상 주소 공간을 갖는 상태를 의미, 시스템 관점에서 실행 중인 프로그램을 의미**
- 처리 상태에 있는 데이터 구조로 표현 가능
  - 스케줄러 ( 디스패치 )에 의해 프로세서 할당
  - 파일에 관련된 자원에 대한 참조 ( 장치 관리, 메모리 관리 )
  - 프로세스 지원과 협력에 관한 정보 ( 교착상태, 보호, 동기화 ) 교환
  - 프로세스 관련 연산은 생성, 종료, 보류, 자원 할당, 해제 등

**실행 유형에 따라 크게 3가지로 구분**
- 운영체제 프로세스
  - 커널 프로세스, 시스템 프로세스라 부른다.
  - 프로세스 실행 순서 제어, 사용하고 있는 프로세스가 다른 사용자나 운영체제 영역을 침범하지 못하게 감시하는 기능 담당
  - 사용자 프로세스 생성, 입출력 프로세스 등 시스템 운영에 필요한 작업 수행 

- 사용자 프로세스
  - 사용자 코드 수행

- 병행 프로세스
  - 독립 프로세스
    - 프로세스 여러개가 병행하여 수행 시 주어진 초기값에 따라 항상 같은 결과를 보여준다.
    - 서로 독립적으로 실행되어 다른 프로세스에 영향을 받지 않고 데이터를 공유하지 않는다.
  - 협동 프로세스
    - 다른 프로세스에 영향을 주거나 다른 프로세스에 의해 영향을 받는다.
    - 컴퓨터 시스템의 제한된 자원을 공유하는 프로세스들이 통제되어 상호 작용해야하는 경우 발생

**실행, 비실행 프로세스 구분**
- 프로세스는 실행되며 상태가 변하므로 운영체제는 프로세스 제어에 필요한 프로세스 상태를 점검해야한다.
  - 운영체제가 프로세스를 새로 생성하면 비실행 상태로 초기화 되어 실행을 기다린다.
  - 실행 중인 프로세스 종료, 인터럽트 발생 시 비실행 프로세스 중 선택된 프로세스가 실행 상태로 변하고 (디스패치) 인터럽트 된 프로세스는 비실행 상태로 변경
- 실행 상태 프로세스
  - 실행 : 명령어가 실행되는 상태, 즉 프로세스가 프로세서를 점유한 상태
  - 대기, 보류 : 프로세서가 이벤트 ( 입출력 종료와 같은 외부 신호 )가 일어나길 기다리는 상태
  - 준비 : 프로세스가 프로세서를 할당 받기 위해 기다리는 상태
- 대부분의 프로세스는 준비, 대기(보류)상태이며, 어느 한 순간에 한 프로세스만 실행 상태가 된다.
- 시스템의 모든 프로세스는 종료되어 시스템을 떠날 때까지 준비, 실행, 대기 상태로 변화되며 실행되는 과정을 반복
- 운영체제는 프로세서 스케쥴러를 이용해 프로세스 상태를 변화를 관리한다.

**작업 스케쥴러**
- 스풀러가 디스크에 저장한 작업들 중 실행할 작업을 선정, 준비 리스트에 삽입
- 이를 통해 다중 프로그래밍의 정도를 결정하는 핵심적인 역할 수행
- 선정한 작업에 대한 프로세스의 생성에서 종료까지의 과정 수행을 위해 상태 변화를 일으킨다.
- 실행 프로세스가 자발적으로 프로세서 반환 전 할당된 시간이 경과하면 준비상태로 변경
- 실행 프로세스가 실행하다 입출력 명령이 발생 시 대기 상태로 변경
- 대기 프로세스는 보류 이유가 제거되면 준비 상태로 변경
- 준비 프로세스는 디스패치가 프로세서를 할당하면 다시 실행상태로 변경

**준비 >> 실행**
- 디스패치 : 준비 리스트 맨 앞에 있던 프로세스가 프로세서를 선택 ( 배당되어 실행 ) 하는 것
- 시간할당
  - 실행 프로세스가 프로세서를 일정 시간만 사용할 수 있도록 시간을 제한
  - 특정 프로세스가 프로세서를 계속 독점하는 것을 방지한다.

**실행 >> 준비**
- 프로세스가 프로세서를 점유한 상태를 "프로세스가 실행 상태에 있다" 라고 한다.
- 운영체제는 프로세스의 독점을 방지하기 위해 인터럽트 클록을 둔다.
  - 특정 프로세스가 일정 시간이 지나도 ( 타임 아웃) 프로세서를 반환하지 않으면 클록이 인터럽트를 발생. 운영체제가 프로세서 제어권을 가진다.
  - 운영체제가 제어권을 가지면 실행 중인 프로세스는 준비 상태로 변화, 준비 리스트의 첫 프로세스가 실행 상태로 변경

**실행 >> 대기(보류)**
- 실행 프로세스가 지정 시간 전에 입출력 연산 등이 필요하거나 새로운 자원 요청 등의 문제 발생 시 스스로 프로세서를 양도하고 대기 상태로 변경

**대기 >> 준비**
- 깨움(wake UP) : 프로세스의 마지막 상태 변화로 입출력 작업이 끝났을 때 발생

**프로세스의 교환은 인터럽트와 트랩, 시스템 호출로 나타낸다**
- 실행 중인 프로세스가 인터럽트 되어 운영체제가 다른 프로세스를 실행 상태로 변경, 제어를 넘겨줄 때 프로세서의 레지스터 내용은 저장해야한다.
- 프로세스는 현재 사용되는 자원에 대한 정보를 가지며, 실행되는 과정에서 여러 프로세스가 파생될 수 있는 능동적인 개체
  - 프로그램은 프로세스 여러 개로 생성될 수 있는 디스크에 저장된 파일 내용으로 정적 단위
- 자원을 할당 받은 상태의 프로그램

_프로세스 관리_
- 실행 중 프로세스 생성 시스템을 호출, 새로운 프로세스를 생성 가능
- 프로세스 생성 순서 저장, 부모 ~ 자식 관계를 유지하며 계층적으로 생성된다.
  - 부모 프로세스 : 생성하는 프로세스
  - 자식 프로세스 : 생성되는 프로세스
- 유닉스 시스템의 일반적인 프로세스 계층 구조
  - 처음 부팅 시 식별자가 0인 첫 번째 프로세스 Swapper 생성
  - Init(PID = 1) Pagedeamon(PID = 2) 생성
  - Swapper(PID = 0) Pagedeamon(PID = 2)를 운영체제 프로세스라 하며 운영체제 모드에서만 실행
  - 모든 사용자 프로세스는 FORK() 명령을 통해 계층적으로 Init의 자식 프로세스 

**프로세스는 운영체제, 다른 사용자의 응용 프로그램 요청에 의해 생성**
- 운영체제가 새로운 프로세스를 생성, 추가하려면 프로세스 관리를 위한 프로세스 제어 블록을 만든 후 프로세스에 주소 공간을 할당해야 한다.
  - 일괄 처리 환경에서는 실행을 위해 작업이 준비 큐에 도착할 때 생성
  - 대화형 환경에서는 새로운 사용자가 로그온 할 때 생성
  - 프로세스 생성을 위한 작업
    - 프로세스 식별자 결정
    - 시스템에 알려진 프로세스 리스트에 식별자 삽입
    - 프로세스에 초기 우선 순위 부여
    - 프로세스 제어 블록 생성
    - 프로세스에 초기 자원 할당

**프로세스가 작업을 수행하기 위해 자원 필요**
- 자식 프로세스 생성 시 필요한 자원을 운영체제로부터 직접, 부모 프로세스의 자원 일부 사용 가능
- 부모 프로세스는 자식 프로세스에 자원을 나눠주거나 일부 자원 공유 가능
  - 자원의 일부만 사용하도록 제한하면 시스템에 부담을 주는 것을 방지 가능하다.
  - 프로세스 생성 시 획득하는 다양한 물리적, 논리적 자원 외에도 약간의 초기화 데이터가 부모 프로세스에서 자식 프로세스로 전달되는 경우도 있다.

**새로운 프로세스 생성 시 실행과 관련해 다음 두 가지 경우가 가능하다**
- 부모 프로세스, 자식 프로세스가 동시에 실행
- 부모 프로세스, 자식 프로세스들이 모두 종료될 때 까지 기다린다.
- 자식 프로세스가 부모 프로세스의 주소공간을 복사
  - 유닉스는 각 프로세스마다 정수로 된 고유한 프로세스 식별자를 가진다.
  - 새로운 프로세스는 fork()명령에 의해 생성, 주소 공간은 부모 프로세스의 주소 공간을 복사한다.
  - 부모 프로세스, 자식 프로세스의 정보 교환이 쉽다.
- 자식 프로세스가 별도의 프로그램을 적재

"윈도우 NT 계열은 새로운 프로세스의 주소 공간을 두 가지 방식을 모두 지원"

**프로세스가 명령 실행 후 종료되고 운영체제에 프로세스 삭제 요청**
- 일괄 처리 환경 : 작업 종료를 의미하는 신호로 인터럽트 발생 또는 시스템 호출로 중지 명령 전달, 프로세스 완료
- 대화형 환경 : 사용자가 로그오프 하거나 터미널을 닫을 때, 오류에 의해 프로세스 종료
- ABORT 시스템 호출을 이용한 프로세스 종료
  - 종료되는 프로세스를 생성한 부모 프로세스만 호출 가능
  - 부모 프로세스가 자식 프로세스의 생존권을 가져 다른 프로세스가 임의로 작업을 중단 시킬 수 없다.
  - 자식 프로세스 종료 시 자식 프로세스의 신원이 부모 프로세스로 전달
