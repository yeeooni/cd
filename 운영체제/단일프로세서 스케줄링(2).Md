# 단일 프로세서 스케줄링 (2)

**스케줄링 알고리즘**
_대부분의 알고리즘은 대화식 사용자 환경과 빠른 응답시간을 구현하는데 집중되었다._
- 프로세스 스케줄러는 프로세스 스케줄링 알고리즘에 따라 프로세서를 할당, 작업을 완료한다.
- 여기서는 단일 프로세서로 구성된 시스템의 스케줄링 알고리즘을 살펴본다.

**선입 선처리 스케줄링(FCFS, First-Come-First-Served)**
_프로세서를 요구 순서대로 할당_
- 비선점 기법으로 프로세서 스케줄링 알고리즘 중 가장 간단하다.
- 선입선출(FIFO, First-In-First-Out) 큐로 구현한다.
- 일괄처리시스템에서는 효율적이나, 대화식시스템에서는 사용자의 빠른 응답 요구에 적합하지 않다.
- 새로운 작업이 시스템에 들어오면 프로세서의 PCB는 준비 큐의 마지막에 연결한다.
- 차례가 되면 준비 큐의 앞부분에 있는 프로세스는 프로세서를 할당 받고 준비 큐에서 삭제된다.
- 성능이 좋지 않는 경우가 많으며 평균 대기시간이 긴 경우도 있다.

**작업의 평균 변환 시간 계산**
- 프로세서 버스트 시간을 알고 있는 다음 세가지 작업의 평균 변환 시간을 계산한다.
- 작업이 P1, P2, P3의 순서로 들어왔다면, 다음과 같은 간트 도표 (GANTT CHEAR)로 나타낸다.
- 반환시간은 P1 24, P2 27, P3 30 평균 반환시간 27(=(24 + 27 + 30) / 3)
- 대기시간은 P1 0, P2 24, P3 27 평균 대기시간 17(=(0 + 24 + 27) / 3 )
- 작업이 P2, P3, P1의 순서로 들어온 경우 간트 도표는 다음과 같다.
- 평균 반환시간은 13(=(3 + 6 + 30) / 3), 평균 대기시간은 3(=(0 + 3 + 6) / 3)으로 단축된다.
- 프로세스의 실행시간에 따라 평균 반환시간과 평균 대기시간은 큰 폭으로 변화한다.

**동적 상황에서의 성능**
- 프로세서 중심 작업 1개와 입출력 중심 작업 3개가 있다고 가정한다.
- 프로세서 중심 프로세스가 프로세서를 할당받아 실행되는동안, 입출력프로세스들은 입출력을 끝내고 준비 큐로 이동하여 프로세서를 기다린다. 이때 입출력 장치들은 쉰다.
- 프로세서 중심 프로세서는 프로세서 작업을 끝내고 다시 입출력 큐로 이동한다. 이때 프로세서는 쉰다.
- 프로세서 중심 프로세서는 다시 준비 큐로 이동하여 프로세서를 할당 받고 다시 모든 입출력 중심의 프로세스들은 프로세서 중심 프로세스가 처리될 때까지 준비 큐에서 대기(반복처리)한다.
- 호위효과(Convoy Effect)
  - 하나의 프로세서 중심 프로세스가 프로세서를 떠나기를 기다리는 현상
  - 결과적으로 프로세서 중심 작업과 입출력 중심 작업의 불균형 상태를 의미한다.
- 선입 선처리 스케줄링 알고리즘은 정기적으로 프로세서를 공유하는 시분할 시스템에서 사용하기 힘들다.

**최소 작업 우선 스케줄링(SJE, Shortest Job First)**
- 프로세서 버스트 시간이 가장 짧은 작업에 프로세서를 할당
  - 이때 두 프로세스가 다음 순서로 동일한 프로세서 버스트를 가진다면 선입 선처리 스케줄링을 적용
  - 다음과 같은 작업들이 준비상태 큐에 있을 때, 최소 작업 우선 스케줄링을 사용하면 간트 도표가 이루어지며, 평균 반환시간은 (=(3 + 9 + 16 + 24) / 4)
  - 선입 선처리 스케줄링 사용 시 간트 도표
  - 평균 반환 시간 14 (=( 6 + 9 + 17 + 24 / 4)이며, 평균 대기시간 8(=(0 + 6 + 9 + 17 ) / 4)

